use eframe::egui;
use egui::{Color32, RichText, Ui};
use std::path::PathBuf;
use std::sync::mpsc::{channel, Receiver, Sender};
use std::time::{SystemTime, UNIX_EPOCH, Duration, Instant};
use chrono::prelude::*;
use std::sync::Arc;
use rayon::ThreadPoolBuilder;
use walkdir;
use open;

use crate::models::{AppState, ConversionType, FileOperation, AppConfig, ConversionStatus, ModStatus, ModInfo, ModsTab};
use crate::converters::mo_converter::MoConverter;
use crate::converters::po_converter::PoConverter;
use crate::converters::po_merger;
use crate::converters::csv_converter::CsvConverter;

// æ·»åŠ åˆå¹¶çŠ¶æ€æšä¸?pub enum MergeStatus {
    Started,
    Progress(f32),
    Completed(PathBuf),
    Failed(String),
}

pub struct App {
    state: AppState,
    config: AppConfig,
    rx: Option<Receiver<(usize, Result<Duration, String>)>>,
    tx: Option<Sender<(usize, Result<Duration, String>)>>,
    merge_rx: Receiver<MergeStatus>,
    merge_tx: Sender<MergeStatus>,
    thread_pool: Arc<rayon::ThreadPool>,
    selected_category: String,
    search_text: String,
    show_install_dialog: bool,
    install_path: String,
}

impl Default for App {
    fn default() -> Self {
        Self::new()
    }
}

impl App {
    pub fn new() -> Self {
        let (tx, rx) = channel();
        let (merge_tx, merge_rx) = channel();
        
        let thread_pool = ThreadPoolBuilder::new()
            .num_threads(num_cpus::get())
            .build()
            .unwrap();
        
        // åŠ è½½é…ç½®æ–‡ä»¶
        let mut config = AppConfig::load();
        
        // åˆ›å»ºåº”ç”¨çŠ¶æ€å¹¶ä»é…ç½®ä¸­è®¾ç½®å€?        let mut state = AppState::default();
        state.main_mo_file = config.main_mo_file.clone();
        
        // è®¾ç½®å›ºå®šçš„è¯­è¨€åŒ…ç›®å½?        let mods_dir = if let Some(local_dir) = dirs::data_local_dir() {
            local_dir.join("BLMM").join("mods")
        } else {
            std::env::temp_dir().join("BLMM").join("mods")
        };
        
        // ç¡®ä¿ç›®å½•å­˜åœ¨
        let _ = std::fs::create_dir_all(&mods_dir);
        
        // è®¾ç½®ç›®å½•
        state.mods_directory = Some(mods_dir.clone());
        config.mods_directory = Some(mods_dir);
        
        // è®¾ç½®è¾“å‡ºç›®å½•
        state.output_directory = config.output_directory.clone();
        
        // ä¸ºäº†å‘åå…¼å®¹ï¼Œæ ¹æ®ä¸»é¢˜è®¾ç½®dark_modeæ ‡å¿—
        state.dark_mode = config.theme != crate::models::AppTheme::Light 
            && config.theme != crate::models::AppTheme::Sepia;
            
        state.auto_batch = config.auto_batch;
        state.auto_close = config.auto_close;
        state.show_logs = config.show_logs;
        state.ignore_main_mo_entries = config.ignore_main_mo_entries;
        
        // é»˜è®¤æ˜¾ç¤ºè¯­è¨€åŒ…ç®¡ç†ç•Œé?        state.show_mods = true;
        state.show_mods_tab = ModsTab::Mods;
            
        let mut app = Self {
            state,
            config,
            rx: Some(rx),
            tx: Some(tx),
            merge_rx,
            merge_tx,
            thread_pool: Arc::new(thread_pool),
            selected_category: "Default".to_string(),
            search_text: String::new(),
            show_install_dialog: false,
            install_path: String::new(),
        };
        
        // å¯åŠ¨æ—¶è‡ªåŠ¨æ‰«æè¯­è¨€åŒ…ç›®å½?        app.scan_mods_directory();
        
        app
    }
    
    fn process_conversion_results(&mut self) {
        if let Some(rx) = &self.rx {
            if let Ok((index, result)) = rx.try_recv() {
                if index < self.state.operations.len() {
                    match result {
                        Ok(duration) => {
                            let now = Local::now();
                            self.state.operations[index].status = ConversionStatus::Completed;
                            self.state.operations[index].end_time = Some(now);
                            
                            // è®¡ç®—è€—æ—¶ï¼ˆæ¯«ç§’å’Œç§’ï¼‰
                            self.state.operations[index].duration = Some(duration.as_secs_f64());
                            self.state.operations[index].elapsed_milliseconds = Some(duration.as_millis());
                            
                            if let Some(output_file) = &self.state.operations[index].output_file {
                                self.state.add_log(&format!("è½¬æ¢æˆåŠŸ: {}", output_file.display()));
                            }
                        }
                        Err(e) => {
                            self.state.operations[index].status = ConversionStatus::Failed;
                            self.state.operations[index].error = Some(e.clone());
                            self.state.add_log(&format!("è½¬æ¢å¤±è´¥: {}", e));
                        }
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰å¾…å¤„ç†çš„ä»»åŠ¡ï¼Œå¦‚æœæœ‰ï¼Œåˆ™è‡ªåŠ¨å¼€å§?                    if self.state.auto_batch {
                        let next_pending = self.state.operations.iter().enumerate()
                            .find(|(_, op)| op.status == ConversionStatus::Pending)
                            .map(|(i, _)| i);
                            
                        if let Some(next_index) = next_pending {
                            self.convert_file(next_index);
                        }
                    }
                } else {
                    self.state.add_log(&format!("é”™è¯¯: æ”¶åˆ°æ— æ•ˆçš„æ“ä½œç´¢å¼?{}", index));
                }
            }
        }
    }
    
    // è½¬æ¢å•ä¸ªæ–‡ä»¶
    fn convert_file(&mut self, operation_index: usize) {
        if operation_index < self.state.operations.len() {
            // æ·»åŠ è°ƒè¯•æ—¥å¿—
            self.state.add_log(&format!("å¼€å§‹è½¬æ¢ä»»åŠ?#{}", operation_index + 1));
            self.start_conversion(operation_index);
        }
    }
    
    fn start_conversion(&mut self, operation_index: usize) {
        if operation_index >= self.state.operations.len() {
            return;
        }
        
        let operation = self.state.operations[operation_index].clone();
        self.state.operations[operation_index].status = ConversionStatus::Processing;
        // è®°å½•å¼€å§‹æ—¶é—?        self.state.operations[operation_index].start_time = Some(Instant::now());
        
        if let Some(tx) = self.tx.clone() {
            let pool = self.thread_pool.clone();
            
            pool.spawn(move || {
                let start = Instant::now();
                
                let result = match operation.conversion_type {
                    ConversionType::MoToPo => {
                        if let (Some(input), Some(output)) = (&operation.input_file, &operation.output_file) {
                            MoConverter::convert_mo_to_po(input, output)
                                .map(|_| start.elapsed())
                        } else {
                            Err("è¾“å…¥æˆ–è¾“å‡ºè·¯å¾„æœªè®¾ç½®".to_string())
                        }
                    }
                    ConversionType::PoToMo => {
                        if let (Some(input), Some(output)) = (&operation.input_file, &operation.output_file) {
                            PoConverter::convert_po_to_mo(input, output)
                                .map(|_| start.elapsed())
                        } else {
                            Err("è¾“å…¥æˆ–è¾“å‡ºè·¯å¾„æœªè®¾ç½®".to_string())
                        }
                    }
                };
                
                let _ = tx.send((operation_index, result));
            });
        }
    }
    
    fn render_header(&mut self, ui: &mut Ui) {
        // è·å–ä¸»é¢˜çš„å¼ºè°ƒè‰²ï¼Œç”¨äºæ ‡é¢?        let accent_color = crate::models::ThemeManager::get_accent_color(&self.config.theme);
        
        ui.heading(RichText::new("Blenderå­—å…¸åˆå¹¶ç®¡ç†å™?By:å‡Œå·é›?).color(accent_color));
        ui.label("å¿«é€Ÿå°†è¯­è¨€åŒ…POæ–‡ä»¶è½¬æ¢å¹¶åˆå¹¶åˆ°MOæ–‡ä»¶ä¸?);
        
        ui.add_space(10.0);
    }
    
    fn render_operations(&mut self, ui: &mut Ui) {
        // è·å–ä¸»é¢˜çš„å¼ºè°ƒè‰²ï¼Œç”¨äºæ ‡é¢?        let accent_color = crate::models::ThemeManager::get_accent_color(&self.config.theme);
        
        ui.heading(RichText::new("æ–‡ä»¶åˆ—è¡¨").color(accent_color));
        
        let mut to_delete = None;
        let mut start_conversion_index = None;
        let mut reset_completed_index = None;
        let mut retry_failed_index = None;
        let mut browse_input_index = None;
        let mut browse_output_index = None;
        
        for (i, operation) in self.state.operations.iter_mut().enumerate() {
        ui.horizontal(|ui| {
                ui.label(format!("{}. ", i + 1));
                
                ui.vertical(|ui| {
                    ui.horizontal(|ui| {
                        ui.label("ç±»å‹: ");
                        ui.radio_value(&mut operation.conversion_type, ConversionType::MoToPo, "MO â†?PO");
                        ui.radio_value(&mut operation.conversion_type, ConversionType::PoToMo, "PO â†?MO");
                    });
                    
                    ui.horizontal(|ui| {
                        ui.label("è¾“å…¥: ");
                        if let Some(input) = &operation.input_file {
                            // åªæ˜¾ç¤ºæ–‡ä»¶å
                            let file_name = input.file_name()
                                .map_or_else(|| "[æœªçŸ¥]".to_string(), 
                                          |name| name.to_string_lossy().to_string());
                            let response = ui.label(file_name);
                            
                            // æ‚¬åœæ—¶æ˜¾ç¤ºå®Œæ•´è·¯å¾?                            let full_path = input.to_string_lossy().to_string();
                            response.on_hover_text(full_path);
                        } else {
                            ui.label("[æœªè®¾ç½®]");
                        }
                        
                        if ui.button("æµè§ˆ").clicked() {
                            browse_input_index = Some(i);
                        }
                    });
                    
                    ui.horizontal(|ui| {
                        ui.label("è¾“å‡º: ");
                        if let Some(output) = &operation.output_file {
                            // åªæ˜¾ç¤ºæ–‡ä»¶å
                            let file_name = output.file_name()
                                .map_or_else(|| "[æœªçŸ¥]".to_string(), 
                                          |name| name.to_string_lossy().to_string());
                            let response = ui.label(file_name);
                            
                            // æ‚¬åœæ—¶æ˜¾ç¤ºå®Œæ•´è·¯å¾?                            let full_path = output.to_string_lossy().to_string();
                            response.on_hover_text(full_path);
                        } else {
                            ui.label("[æœªè®¾ç½®]");
                        }
                        
                        if ui.button("æµè§ˆ").clicked() {
                            browse_output_index = Some(i);
                        }
                    });
                    
                    ui.horizontal(|ui| {
                        ui.label("çŠ¶æ€? ");
                        match operation.status {
                            ConversionStatus::Pending => {
                                ui.label(operation.status.to_string());
                                if ui.button("å¼€å§?).clicked() {
                                    start_conversion_index = Some(i);
                                }
                            },
                            ConversionStatus::Processing => {
                                if let Some(start) = operation.start_time {
                                    let elapsed = start.elapsed();
                                    ui.label(format!("å¤„ç†ä¸?({:.2}ç§?...", elapsed.as_secs_f64()));
                                } else {
                                    ui.label("å¤„ç†ä¸?..");
                                }
                            },
                            ConversionStatus::Completed => {
                                // è·å–æˆåŠŸçŠ¶æ€é¢œè‰?                                let (_success_color, _warning_color, _error_color, _info_color) =
                                    crate::models::ThemeManager::get_status_colors();
                                ui.label(RichText::new("å®Œæˆ").color(Color32::LIGHT_BLUE));
                                if let Some(duration) = operation.duration {
                                    ui.label(format!("({:.3}ç§?", duration));
                                }
                                if let Some(elapsed_ms) = operation.elapsed_milliseconds {
                                    ui.label(format!("[{}æ¯«ç§’]", elapsed_ms));
                                }
                                
                                if ui.button("å†æ¬¡è½¬æ¢").clicked() {
                                    reset_completed_index = Some(i);
                                }
                            },
                            ConversionStatus::Failed => {
                                // è·å–é”™è¯¯çŠ¶æ€é¢œè‰?                                let (_success_color, _warning_color, _error_color, _info_color) =
                                    crate::models::ThemeManager::get_status_colors();
                                ui.label(RichText::new("å¤±è´¥").color(Color32::RED));
                                if let Some(error) = &operation.error {
                                    ui.label(RichText::new(error).color(Color32::RED));
                                }
                                
                                if ui.button("é‡è¯•").clicked() {
                                    retry_failed_index = Some(i);
                                }
                            },
                        }
                        
                        if ui.button("åˆ é™¤").clicked() {
                            to_delete = Some(i);
                        }
                    });
                });
            });
            
        ui.separator();
    }
    
        // å¤„ç†æµè§ˆè¾“å…¥æ–‡ä»¶
        if let Some(i) = browse_input_index {
            if i < self.state.operations.len() {
                let operation = &mut self.state.operations[i];
                let ext = match operation.conversion_type {
                    ConversionType::MoToPo => "mo",
                    _ => "po"
                };
                
                if let Some(file) = rfd::FileDialog::new()
                    .add_filter("æ–‡ä»¶", &[ext])
                    .pick_file() {
                        operation.input_file = Some(file.clone());
                        
                        // è‡ªåŠ¨è®¾ç½®è¾“å‡ºæ–‡ä»¶å?                        let mut output_file = file.clone();
                        let new_ext = if ext == "mo" { "po" } else { "mo" };
                        output_file.set_extension(new_ext);
                        operation.output_file = Some(output_file);
                    }
            }
        }
        
        // å¤„ç†æµè§ˆè¾“å‡ºæ–‡ä»¶
        if let Some(i) = browse_output_index {
            if i < self.state.operations.len() {
                let operation = &mut self.state.operations[i];
                let ext = match operation.conversion_type {
                    ConversionType::MoToPo => "po",
                    ConversionType::PoToMo => "mo",
                };
                
                if let Some(file) = rfd::FileDialog::new()
                    .add_filter("æ–‡ä»¶", &[ext])
                    .save_file() {
                        operation.output_file = Some(file);
                    }
            }
        }
        
        // å¤„ç†é‡ç½®æ“ä½œ
        if let Some(i) = reset_completed_index {
            if i < self.state.operations.len() {
                let operation = &mut self.state.operations[i];
                operation.status = ConversionStatus::Pending;
                operation.start_time = None;
                operation.end_time = None;
                operation.duration = None;
                operation.elapsed_milliseconds = None;
                operation.error = None;
                self.convert_file(i);
            }
        }
        
        // å¤„ç†é‡è¯•æ“ä½œ
        if let Some(i) = retry_failed_index {
            if i < self.state.operations.len() {
                let operation = &mut self.state.operations[i];
                operation.status = ConversionStatus::Pending;
                operation.error = None;
                self.convert_file(i);
            }
        }
        
        // å¤„ç†å¼€å§‹è½¬æ¢æ“ä½?        if let Some(i) = start_conversion_index {
            self.convert_file(i);
        }
        
        // å¤„ç†åˆ é™¤æ“ä½œ
        if let Some(i) = to_delete {
            self.state.operations.remove(i);
        }
        
        ui.horizontal(|ui| {
            let accent_color = crate::models::ThemeManager::get_accent_color(&self.config.theme);
            
            // æ ·å¼åŒ–çš„æ·»åŠ æŒ‰é’®
            if ui.add(egui::Button::new(RichText::new("æ·»åŠ MOâ†’POä»»åŠ¡").color(accent_color))
                     .min_size(egui::vec2(140.0, 24.0)))
                     .clicked() {
                self.open_specific_file_dialog(ConversionType::MoToPo);
            }
            
            if ui.add(egui::Button::new(RichText::new("æ·»åŠ POâ†’MOä»»åŠ¡").color(accent_color))
                     .min_size(egui::vec2(140.0, 24.0)))
                     .clicked() {
                self.open_specific_file_dialog(ConversionType::PoToMo);
            }
            
            let (_success_color, _warning_color, _error_color, _info_color) =
                crate::models::ThemeManager::get_status_colors();
            
            if ui.add(egui::Button::new(RichText::new("æ‰¹é‡å¤„ç†").color(Color32::LIGHT_BLUE))
                     .min_size(egui::vec2(100.0, 24.0)))
                     .clicked() {
                self.batch_process();
            }
            
            ui.separator();
            
            ui.checkbox(&mut self.state.auto_close, "å¤„ç†å®Œæˆåè‡ªåŠ¨å…³é—?);
            ui.checkbox(&mut self.state.auto_batch, "è‡ªåŠ¨æ‰¹å¤„ç?);
            
            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                ui.label(format!("çº¿ç¨‹æ±? {} çº¿ç¨‹", num_cpus::get()));
            });
        });
    }
    
    fn render_logs(&mut self, ui: &mut Ui) {
        ui.collapsing("æ—¥å¿—", |ui| {
            egui::ScrollArea::vertical().max_height(150.0).show(ui, |ui| {
                for log in &self.state.logs {
                    ui.label(log);
                }
                
                // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ?                if !self.state.logs.is_empty() {
                    ui.scroll_to_cursor(Some(egui::Align::BOTTOM));
                }
            });
        });
    }
    
    fn render_settings(&mut self, _ctx: &egui::Context) {
        if self.state.show_settings {
            // å½“é€šè¿‡èœå•æ‰“å¼€è®¾ç½®çª—å£æ—¶ï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ°è¯­è¨€åŒ…ç®¡ç†å™¨çš„è®¾ç½®æ ‡ç­¾é¡µ
            self.state.show_mods = true;
            self.state.show_mods_tab = ModsTab::Settings;
            self.state.show_settings = false;
        }
    }
    
    // æ‰“å¼€æ–‡ä»¶é€‰æ‹©å¯¹è¯æ¡?    #[allow(dead_code)]
    fn open_file_dialog(&mut self) {
        // åˆ›å»ºä¸€ä¸ªæ–°çš„æ“ä½œï¼Œä½¿ç”¨å½“å‰åº”ç”¨çŠ¶æ€çš„è½¬æ¢ç±»å‹
        let mut new_operation = FileOperation::default();
        
        // æ ¹æ®å½“å‰è½¬æ¢ç±»å‹è®¾ç½®æ–‡ä»¶è¿‡æ»¤å™?        let ext = match new_operation.conversion_type {
            ConversionType::MoToPo => "mo",
            _ => "po"
        };
        
        // æ·»åŠ è°ƒè¯•æ—¥å¿—
        self.state.add_log(&format!("æ­£åœ¨é€‰æ‹©{}æ–‡ä»¶...", ext));
        
        // æ‰“å¼€æ–‡ä»¶é€‰æ‹©å¯¹è¯æ¡?        if let Some(file) = rfd::FileDialog::new()
            .add_filter("æ–‡ä»¶", &[ext])
            .set_title(&format!("é€‰æ‹©{}æ–‡ä»¶", ext))
                                .pick_file() {
                new_operation.input_file = Some(file.clone());
                                    
                                    // è‡ªåŠ¨è®¾ç½®è¾“å‡ºæ–‡ä»¶å?                let mut output_file = file.clone();
                let new_ext = if ext == "mo" { "po" } else { "mo" };
                output_file.set_extension(new_ext);
                new_operation.output_file = Some(output_file.clone());
                
                // æ·»åŠ åˆ°æ“ä½œåˆ—è¡?                self.state.operations.push(new_operation);
                self.state.add_log(&format!("å·²æ·»åŠ æ–°ä»»åŠ¡: {} â†?{}", 
                    file.display(), 
                    output_file.display()));
            } else {
                self.state.add_log("æ–‡ä»¶é€‰æ‹©å·²å–æ¶?);
            }
    }
    
    // æ‰¹é‡å¤„ç†æ‰€æœ‰å¾…å¤„ç†çš„æ–‡ä»?    fn batch_process(&mut self) {
        // è·å–æ‰€æœ‰å¾…å¤„ç†çš„æ–‡ä»¶ç´¢å¼?        let pending_indices: Vec<usize> = self.state.operations.iter().enumerate()
            .filter(|(_, op)| op.status == ConversionStatus::Pending)
            .map(|(i, _)| i)
            .collect();
            
        // å¼€å§‹å¤„ç†ç¬¬ä¸€ä¸ªæ–‡ä»?        if let Some(&index) = pending_indices.first() {
            self.convert_file(index);
        }
    }

    #[allow(dead_code)]
    fn format_time(dt: &DateTime<Local>) -> String {
        dt.format("%Y-%m-%d %H:%M:%S").to_string()
    }

    // æ·»åŠ æ–°çš„æ–‡ä»¶é€‰æ‹©å¯¹è¯æ¡†å‡½æ•°ï¼Œå¯ä»¥æŒ‡å®šè½¬æ¢ç±»å‹
    fn open_specific_file_dialog(&mut self, conversion_type: ConversionType) {
        // åˆ›å»ºä¸€ä¸ªæ–°çš„æ“ä½œï¼Œè®¾ç½®æŒ‡å®šçš„è½¬æ¢ç±»å?        let mut new_operation = FileOperation::default();
        new_operation.conversion_type = conversion_type;
        
        // æ ¹æ®è½¬æ¢ç±»å‹è®¾ç½®æ–‡ä»¶è¿‡æ»¤å™?        let ext = match conversion_type {
            ConversionType::MoToPo => "mo",
            ConversionType::PoToMo => "po",
        };
        
        // æ·»åŠ è°ƒè¯•æ—¥å¿—
        self.state.add_log(&format!("æ­£åœ¨é€‰æ‹©{}æ–‡ä»¶...", ext));
        
        // æ‰“å¼€æ–‡ä»¶é€‰æ‹©å¯¹è¯æ¡?        if let Some(file) = rfd::FileDialog::new()
            .add_filter("æ–‡ä»¶", &[ext])
            .set_title(&format!("é€‰æ‹©{}æ–‡ä»¶", ext))
            .pick_file() 
        {
            new_operation.input_file = Some(file.clone());
            
            // è‡ªåŠ¨è®¾ç½®è¾“å‡ºæ–‡ä»¶å?            let mut output_file = file.clone();
            let new_ext = if ext == "mo" { "po" } else { "mo" };
            output_file.set_extension(new_ext);
            new_operation.output_file = Some(output_file.clone());
            
            // æ·»åŠ åˆ°æ“ä½œåˆ—è¡?            self.state.operations.push(new_operation);
            self.state.add_log(&format!("å·²æ·»åŠ æ–°ä»»åŠ¡: {} â†?{}", 
                file.display(), 
                output_file.display()));
        } else {
            self.state.add_log("æ–‡ä»¶é€‰æ‹©å·²å–æ¶?);
        }
    }

    fn render_mods(&mut self, ui: &mut Ui) {
        // è·å–ä¸»é¢˜å¼ºè°ƒè‰?        let accent_color = crate::models::ThemeManager::get_accent_color(&self.config.theme);
        
        // Top menu bar
        ui.horizontal(|ui| {
            if ui.selectable_label(self.state.show_mods_tab == ModsTab::Mods, 
                           RichText::new("è¯­è¨€åŒ?).color(
                               if self.state.show_mods_tab == ModsTab::Mods { accent_color } 
                               else { ui.style().visuals.text_color() }
                           )).clicked() {
                self.state.show_mods_tab = ModsTab::Mods;
            }
            if ui.selectable_label(self.state.show_mods_tab == ModsTab::Package, 
                           RichText::new("ä»“åº“").color(
                               if self.state.show_mods_tab == ModsTab::Package { accent_color } 
                               else { ui.style().visuals.text_color() }
                           )).clicked() {
                self.state.show_mods_tab = ModsTab::Package;
            }
            if ui.selectable_label(self.state.show_mods_tab == ModsTab::Settings, 
                           RichText::new("è®¾ç½®").color(
                               if self.state.show_mods_tab == ModsTab::Settings { accent_color } 
                               else { ui.style().visuals.text_color() }
                           )).clicked() {
                self.state.show_mods_tab = ModsTab::Settings;
            }
        });

        ui.separator();

        match self.state.show_mods_tab {
            ModsTab::Mods => self.render_mods_list(ui),
            ModsTab::Package => self.render_package_tab(ui),
            ModsTab::Settings => self.render_mod_settings(ui),
        }
    }

    fn render_mods_list(&mut self, ui: &mut Ui) {
        // è·å–ä¸»é¢˜é¢œè‰²
        let accent_color = crate::models::ThemeManager::get_accent_color(&self.config.theme);
        let (_success_color, _warning_color, _error_color, _info_color) =
            crate::models::ThemeManager::get_status_colors();
        
        // Top controls
        ui.horizontal(|ui| {
            ui.push_id("mods_combobox", |ui| {
                egui::ComboBox::from_id_source("profile_selector")
                    .selected_text(&self.selected_category)
                    .show_ui(ui, |ui| {
                        ui.selectable_value(&mut self.selected_category, "Default".to_string(), "é»˜è®¤");
                        // Could add other categories here
                    });
            });

            if ui.button("+").clicked() {
                // Add new profile
            }
            if ui.button("â‰?).clicked() {
                // Show profile options
            }

            // æ·»åŠ "å®‰è£…è¯­è¨€åŒ?æŒ‰é’®ï¼Œä½¿ç”¨å¼ºè°ƒè‰²
            if ui.add(egui::Button::new(RichText::new("å®‰è£…è¯­è¨€åŒ?å¯å¤šé€?").color(accent_color))
                     .min_size(egui::vec2(150.0, 24.0)))
                     .clicked() {
                self.install_new_mod();
            }

            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                let enabled_count = self.state.installed_mods.iter().filter(|m| m.status == ModStatus::Enabled).count();
                ui.label(format!("{} è¯­è¨€åŒ?/ {} å·²å¯ç”?, self.state.installed_mods.len(), enabled_count));
                
                // æ·»åŠ "å¯¼å‡ºåŸºç¡€æ–‡ä»¶"æŒ‰é’® - æ”¾åœ¨åˆå¹¶æŒ‰é’®æ—è¾¹
                ui.add_space(5.0); // å¢åŠ ä¸€ç‚¹é—´è·?                if ui.add(egui::Button::new(RichText::new("å¯¼å‡ºåŸºç¡€æ–‡ä»¶").color(Color32::LIGHT_GREEN))
                    .min_size(egui::vec2(110.0, 28.0)))
                    .on_hover_text("ç›´æ¥å¯¼å‡ºåŸºç¡€MOæ–‡ä»¶ï¼ˆä¸åˆå¹¶ï¼‰ï¼Œä»åç§°ä¸­ç§»é™¤base")
                    .clicked() {
                    self.export_base_mo_file();
                }
                
                // å½“æœ‰å¯ç”¨çš„è¯­è¨€åŒ…æ—¶æˆ–éœ€è¦é‡æ–°åˆå¹¶æ—¶æ˜¾ç¤ºåˆå¹¶æŒ‰é’®
                if enabled_count > 0 || self.state.needs_remerge {
                    // å¦‚æœéœ€è¦é‡æ–°åˆå¹¶ï¼Œæ˜¾ç¤º"é‡æ–°åˆå¹¶"æŒ‰é’®å¹¶ä½¿ç”¨ä¸åŒé¢œè‰?                    ui.push_id("remerge_button", |ui| {
                        // è·å–çŠ¶æ€é¢œè‰?                        let (_success_color, _warning_color, _error_color, _info_color) =
                            crate::models::ThemeManager::get_status_colors();
                        
                        // å¦‚æœæ­£åœ¨åˆå¹¶ä¸­ï¼Œæ˜¾ç¤ºè¿›åº¦åŠ¨ç”»
                        if self.state.is_merging {
                            let text = format!("åˆå¹¶ä¸­{}", ".".repeat(((self.state.merge_progress_anim / 10) % 4) as usize));
                            ui.add(egui::ProgressBar::new(self.state.merge_progress)
                                .text(RichText::new(text).color(Color32::LIGHT_BLUE))
                                .fill(Color32::LIGHT_BLUE)
                                .animate(true));
                        } else {
                            let button_text = if self.state.needs_remerge {
                                RichText::new("é‡æ–°åˆå¹¶").color(Color32::LIGHT_BLUE)
                            } else {
                                RichText::new("åº”ç”¨åˆ°MOæ–‡ä»¶").color(Color32::LIGHT_BLUE)
                            };
                            
                            // æ³¨æ„è¿™é‡Œä½¿ç”¨äº†æ­£ç¡®çš„æŒ‰é’®æ„é€ æ–¹å¼?                            let merge_button = egui::Button::new(button_text)
                                .min_size(egui::vec2(130.0, 28.0));
                                
                            if ui.add(merge_button).clicked() {
                                // è®¾ç½®åˆå¹¶çŠ¶æ€å¹¶å¯åŠ¨çº¿ç¨‹
                                self.state.is_merging = true;
                                self.state.merge_progress = 0.0;
                                self.state.merge_progress_anim = 0;
                                
                                // åœ¨çº¿ç¨‹ä¸­æ‰§è¡Œåˆå¹¶ï¼Œä»¥é¿å…UIå†»ç»“
                                let tx = self.merge_tx.clone();
                                let po_files: Vec<PathBuf> = self.state.installed_mods.iter()
                                    .filter(|m| m.status == ModStatus::Enabled)
                                    .map(|m| m.path.clone())
                                    .collect();
                                let ignore_main = self.state.ignore_main_mo_entries;
                                
                                self.thread_pool.spawn(move || {
                                    // é€šçŸ¥å¼€å§?                                    let _ = tx.send(MergeStatus::Started);
                                    
                                    // åˆ›å»ºç¼“å­˜ç›®å½•
                                    let cache_dir = if let Some(local_dir) = dirs::data_local_dir() {
                                        local_dir.join("BLMM").join("cache")
                                    } else {
                                        std::env::temp_dir().join("BLMM").join("cache")
                                    };
                                    
                                    if let Err(e) = std::fs::create_dir_all(&cache_dir) {
                                        let _ = tx.send(MergeStatus::Failed(format!("åˆ›å»ºç¼“å­˜ç›®å½•å¤±è´¥: {}", e)));
                                        return;
                                    }
                                    
                                    // ç¼“å­˜åˆå¹¶POçš„è·¯å¾?                                    let cached_po_path = cache_dir.join("cached_merged.po");
                                    
                                    // æ›´æ–°è¿›åº¦ 25%
                                    let _ = tx.send(MergeStatus::Progress(0.25));
                                    
                                    // åˆå¹¶POæ–‡ä»¶
                                    match po_merger::merge_po_files(&po_files, &cached_po_path, ignore_main) {
                                        Ok(_) => {
                                            // æ›´æ–°è¿›åº¦ 75%
                                            let _ = tx.send(MergeStatus::Progress(0.75));
                                            
                                            // å®Œæˆ
                                            let _ = tx.send(MergeStatus::Completed(cached_po_path));
                                        },
                                        Err(e) => {
                                            let _ = tx.send(MergeStatus::Failed(format!("åˆå¹¶POæ–‡ä»¶å¤±è´¥: {}", e)));
                                        }
                                    }
                                });
                            }
                        }
                    });
                }
            });
        });

        // Table header
        ui.horizontal(|ui| {
            ui.add_space(30.0); // Checkbox column
            ui.label("è¯­è¨€åŒ…åç§?).on_hover_text("æŒ‰åç§°æ’åº?);
            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                ui.label("ä¼˜å…ˆçº?â–?).on_hover_text("æ•°å­—è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜ï¼Œä¼˜å…ˆçº§é«˜çš„ç¿»è¯‘å°†è¦†ç›–ä¼˜å…ˆçº§ä½çš„ç¿»è¯?);
                ui.label("ç‰ˆæœ¬");
                ui.label("ç±»åˆ«");
            });
        });

        ui.separator();

        // è®¡ç®—åˆé€‚çš„é«˜åº¦ï¼Œä¿ç•™è¶³å¤Ÿç©ºé—´ç»™æ—¥å¿—åŒºåŸŸ
        let available_height = ui.available_height();
        // ç•™å‡ºæ—¥å¿—åŒºåŸŸé«˜åº¦ï¼ˆå¦‚æœæ—¥å¿—å¯è§ï¼‰
        let log_area_height = if self.state.show_logs { 220.0 } else { 0.0 };
        let mods_list_height = available_height - log_area_height - 40.0; // é¢å¤–ç•™å‡ºä¸€äº›ç©ºé—´ç»™UIå…ƒç´ 

        // Mods list
        let mut to_enable = None;
        let mut to_disable = None;
        let mut to_uninstall = None;

        // æ‹–æ”¾åŠŸèƒ½å·²ç§»é™?        // æ ¹æ®ç”¨æˆ·è¦æ±‚ï¼Œå·²åˆ é™¤æ‹–æ‹½å®‰è£…POæ–‡ä»¶çš„åŠŸèƒ?
        // å¦‚æœæ²¡æœ‰modsï¼Œæ˜¾ç¤ºä¸€ä¸ªæç¤ºåŒºåŸ?        if self.state.installed_mods.is_empty() {
            let available_rect = ui.available_rect_before_wrap();
            let empty_area_rect = egui::Rect::from_min_size(
                available_rect.min,
                egui::Vec2::new(available_rect.width(), mods_list_height)
            );
            
            let empty_area_response = ui.allocate_rect(
                empty_area_rect,
                egui::Sense::hover()
            );
            
            let painter = ui.painter();
            let rect = empty_area_response.rect;
            
            painter.rect_stroke(
                rect,
                5.0,
                egui::Stroke::new(1.0, Color32::from_rgb(100, 100, 100))
            );
            
            painter.text(
                rect.center(),
                egui::Align2::CENTER_CENTER,
                "ç‚¹å‡»ä¸Šæ–¹\"å®‰è£…è¯­è¨€åŒ…\"æŒ‰é’®æ·»åŠ è¯­è¨€åŒ?,
                egui::TextStyle::Body.resolve(ui.style()),
                Color32::from_rgb(180, 180, 180)
            );
        } else {
            // å¦‚æœæœ‰modsï¼Œæ˜¾ç¤ºä¸€ä¸ªå¯æ»šåŠ¨åˆ—è¡¨
            ui.push_id("mods_list_scroll", |ui| {
                egui::ScrollArea::vertical().max_height(mods_list_height).show(ui, |ui| {
                    let mut move_up_index = None;
                    let mut move_down_index = None;
                    
                    for (index, mod_info) in self.state.installed_mods.iter().enumerate() {
                        ui.push_id(index, |ui| {
                            let row_response = ui.horizontal(|ui| {
                                // Checkbox for enabled/disabled
                                let mut is_enabled = mod_info.status == ModStatus::Enabled;
                                
                                // ä½¿ç”¨on_changeæ¥æ£€æµ‹å¤é€‰æ¡†çŠ¶æ€å˜åŒ?                                if ui.checkbox(&mut is_enabled, "").changed() {
                                    // åªæœ‰å½“çŠ¶æ€ç¡®å®å‘ç”Ÿå˜åŒ–æ—¶æ‰æ·»åŠ åˆ°å¾…å¤„ç†é˜Ÿåˆ?                                    if is_enabled {
                                        to_enable = Some(index);
                                    } else {
                                        to_disable = Some(index);
                                    }
                                    
                                    // ç›´æ¥åœ¨æ­¤å¤„è®¾ç½®needs_remergeæ ‡å¿—
                                    self.state.needs_remerge = true;
                                }

                                // Color the selected row
                                let text_color = if is_enabled { Color32::LIGHT_BLUE } else { ui.style().visuals.text_color() };
                                ui.colored_label(text_color, &mod_info.name);

                                // Right side of the row
                                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                    // æ·»åŠ ä¸Šä¸‹ç§»åŠ¨æŒ‰é’®
                                    let can_move_down = index < self.state.installed_mods.len() - 1;
                                    let can_move_up = index > 0;
                                    
                                    if ui.add_enabled(can_move_down, egui::Button::new("â–?)).clicked() {
                                        // ä¸‹ç§»
                                        move_down_index = Some(index);
                                    }
                                    
                                    if ui.add_enabled(can_move_up, egui::Button::new("â–?)).clicked() {
                                        // ä¸Šç§»
                                        move_up_index = Some(index);
                                    }
                                    
                                    ui.label(format!("{}", index)); // Priority
                                    ui.label(mod_info.version.as_deref().unwrap_or("1.0.0")); // Version
                                    ui.label(mod_info.description.as_deref().unwrap_or("è¯­è¨€åŒ?)); // Category
                                });
                            });

                            // Highlight when hovered
                            if row_response.response.hovered() {
                                row_response.response.clone().highlight();
                            }

                            // Context menu
                            row_response.response.context_menu(|ui| {
                                if ui.button("é‡å‘½å?).clicked() {
                                    // æ‰“å¼€é‡å‘½åå¯¹è¯æ¡†
                                    let mod_name = self.state.installed_mods[index].name.clone();
                                    self.state.rename_mod_index = Some(index);
                                    self.state.rename_mod_name = mod_name;
                                    ui.close_menu();
                                }
                                
                                if ui.button("å¸è½½").clicked() {
                                    to_uninstall = Some(index);
                                    ui.close_menu();
                                }
                            });
                        });

                        ui.separator();
                    }
                    
                    // å¤„ç†ä¼˜å…ˆçº§ç§»åŠ¨æ“ä½?                    if let Some(index) = move_up_index {
                        if index > 0 {
                            self.state.installed_mods.swap(index, index - 1);
                            self.state.needs_remerge = true;
                        }
                    }
                    
                    if let Some(index) = move_down_index {
                        if index < self.state.installed_mods.len() - 1 {
                            self.state.installed_mods.swap(index, index + 1);
                            self.state.needs_remerge = true;
                        }
                    }
                });
            });
        }

        // Handle mod state changes
        if let Some(index) = to_enable {
            self.enable_mod(index);
        }
        
        if let Some(index) = to_disable {
            self.disable_mod(index);
        }
        
        if let Some(index) = to_uninstall {
            self.uninstall_mod(index);
        }

        // æ˜¾ç¤ºæ—¥å¿—åŒºåŸŸï¼ˆå¦‚æœå¯ç”¨ï¼‰
        if self.state.show_logs {
            ui.separator();
            ui.horizontal(|ui| {
                ui.heading("æ—¥å¿—");
                if ui.button("æ¸…ç©º").clicked() {
                    self.state.logs.clear();
                }
                
                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    ui.text_edit_singleline(&mut self.search_text).on_hover_text("æœç´¢æ—¥å¿—");
                    ui.label("æœç´¢:");
                    
                    if ui.button(if self.state.show_logs { "éšè—æ—¥å¿—" } else { "æ˜¾ç¤ºæ—¥å¿—" }).clicked() {
                        self.state.show_logs = !self.state.show_logs;
                        // ä¿å­˜é…ç½®
                        self.config.show_logs = self.state.show_logs;
                        self.config.save().ok();
                    }
                });
            });

            ui.push_id("logs_scroll", |ui| {
                egui::ScrollArea::vertical().max_height(200.0).show(ui, |ui| {
                for log in &self.state.logs {
                        if self.search_text.is_empty() || log.to_lowercase().contains(&self.search_text.to_lowercase()) {
                    ui.label(log);
                        }
                }
                
                    // Auto-scroll to the latest log
                if !self.state.logs.is_empty() {
                    ui.scroll_to_cursor(Some(egui::Align::BOTTOM));
                }
            });
        });
    }
    
        // Install dialog
        self.render_install_dialog(ui.ctx());
    }

    // Get or create mods cache directory
    fn get_or_create_mods_cache_dir(&self) -> Option<PathBuf> {
        // ä½¿ç”¨ AppData\Local\BLMM\mods ç›®å½•ä½œä¸ºé»˜è®¤ç›®å½•
        let cache_dir = if let Some(local_dir) = dirs::data_local_dir() {
            local_dir.join("BLMM").join("mods")
        } else {
            // å¦‚æœæ— æ³•è·å–ç³»ç»Ÿæœ¬åœ°æ•°æ®ç›®å½•ï¼Œä½¿ç”¨ä¸´æ—¶ç›®å½?            std::env::temp_dir().join("BLMM").join("mods")
        };
        
        // ç¡®ä¿ç›®å½•å­˜åœ¨
        if let Err(e) = std::fs::create_dir_all(&cache_dir) {
            eprintln!("åˆ›å»ºè¯­è¨€åŒ…ç¼“å­˜ç›®å½•å¤±è´? {}", e);
            return None;
        }
        
        Some(cache_dir)
    }

    // Generate the cached merged PO file from selected mods
    #[allow(dead_code)]
    fn generate_cached_merged_po(&mut self) {
        // è¯¥æ–¹æ³•ç°åœ¨è¢«çº¿ç¨‹åŒ–å¤„ç†ï¼Œè¿™é‡Œä¸éœ€è¦ä»»ä½•æ“ä½?        // æ‰€æœ‰é€»è¾‘éƒ½ç§»åˆ°äº†ç‚¹å‡»äº‹ä»¶å’Œprocess_merge_statusæ–¹æ³•ä¸?    }

    // Apply the cached merged PO file to the main MO file
    fn apply_merged_po_to_mo(&mut self) {
        // Check if we have main MO file and cached merged PO
        if self.state.main_mo_file.is_none() {
            self.state.add_log("é”™è¯¯: è¯·å…ˆåœ¨è®¾ç½®ä¸­è®¾ç½®ä¸»MOæ–‡ä»¶");
            return;
        }
        
        if self.state.cached_merged_po.is_none() {
            self.state.add_log("é”™è¯¯: æ²¡æœ‰å¯ç”¨çš„åˆå¹¶POç¼“å­˜ï¼Œè¯·å…ˆç‚¹å‡?åˆå¹¶é€‰ä¸­PO'");
            return;
        }
        
        let main_mo_file = self.state.main_mo_file.clone().unwrap();
        let cached_po_file = self.state.cached_merged_po.clone().unwrap();
        
        // ä½¿ç”¨ AppData\Local\BLMM\cache ç›®å½•
        let cache_dir = if let Some(local_dir) = dirs::data_local_dir() {
            local_dir.join("BLMM").join("cache")
        } else {
            // å¦‚æœæ— æ³•è·å–ç³»ç»Ÿæœ¬åœ°æ•°æ®ç›®å½•ï¼Œä½¿ç”¨ä¸´æ—¶ç›®å½?            std::env::temp_dir().join("BLMM").join("cache")
        };
        
        // ç¡®ä¿ç¼“å­˜ç›®å½•å­˜åœ¨
        if let Err(e) = std::fs::create_dir_all(&cache_dir) {
            self.state.add_log(&format!("åˆ›å»ºç¼“å­˜ç›®å½•å¤±è´¥: {}", e));
            return;
        }
        
        // Create output MO file path - ä½¿ç”¨ç”¨æˆ·è®¾ç½®çš„è¾“å‡ºç›®å½•æˆ–æ¡Œé¢ä¸Šçš„"BLMMå¯¼å‡º"æ–‡ä»¶å¤?        let output_mo_path = if let Some(output_dir) = &self.state.output_directory {
            // ä½¿ç”¨ç”¨æˆ·è®¾ç½®çš„è¾“å‡ºç›®å½?            if let Err(e) = std::fs::create_dir_all(output_dir) {
                self.state.add_log(&format!("åˆ›å»ºè¾“å‡ºç›®å½•å¤±è´¥: {}", e));
                // å¦‚æœåˆ›å»ºç›®å½•å¤±è´¥ï¼Œå›é€€åˆ°æ¡Œé¢ä¸Šçš?BLMMå¯¼å‡º"æ–‡ä»¶å¤?                self.create_default_output_directory()
                    .map(|dir| dir.join("blender.mo"))
                    .unwrap_or_else(|| cache_dir.join("blender.mo"))
            } else {
                // ä½¿ç”¨è®¾ç½®çš„è¾“å‡ºç›®å½?                output_dir.join("blender.mo")
            }
        } else {
            // æœªè®¾ç½®è¾“å‡ºç›®å½•ï¼Œä½¿ç”¨æ¡Œé¢ä¸Šçš„"BLMMå¯¼å‡º"æ–‡ä»¶å¤?            self.create_default_output_directory()
                .map(|dir| dir.join("blender.mo"))
                .unwrap_or_else(|| {
                    // å¦‚æœåˆ›å»ºæ¡Œé¢æ–‡ä»¶å¤¹å¤±è´¥ï¼Œå›é€€åˆ°ä¸»MOæ–‡ä»¶æ‰€åœ¨ç›®å½?                    if let Some(parent) = main_mo_file.parent() {
                        parent.join("blender.mo")
                    } else {
                        cache_dir.join("blender.mo")
                    }
                })
        };
        
        // Convert the main MO file to PO first
        let main_po_path = cache_dir.join("main.po");
        self.state.add_log("æ­£åœ¨å°†ä¸»MOæ–‡ä»¶è½¬æ¢ä¸ºPOæ ¼å¼...");
        
        match MoConverter::convert_mo_to_po(&main_mo_file, &main_po_path) {
            Ok(_) => {
                self.state.add_log("ä¸»MOæ–‡ä»¶è½¬æ¢æˆåŠŸï¼Œå‡†å¤‡ä¸ç¼“å­˜POåˆå¹¶...");
                
                // Merge main PO with cached PO
                let all_po_files = vec![main_po_path.clone(), cached_po_file];
                let final_merged_po = cache_dir.join("final_merged.po");
                
                // è®°å½•æ˜¯å¦ä½¿ç”¨äº†å¿½ç•¥ä¸»moæ¡ç›®çš„é€‰é¡¹
                let ignore_msg = if self.state.ignore_main_mo_entries {
                    "ï¼ˆå·²å¯ç”¨å¿½ç•¥ä¸»MOæ¡ç›®æ¨¡å¼ï¼?
                } else {
                    ""
                };
                
                match po_merger::merge_po_files(&all_po_files, &final_merged_po, self.state.ignore_main_mo_entries) {
                    Ok(_) => {
                        self.state.add_log(&format!("æœ€ç»ˆPOæ–‡ä»¶åˆå¹¶æˆåŠŸ{}ï¼Œæ­£åœ¨è½¬æ¢ä¸ºMOæ ¼å¼...", ignore_msg));
                        
                        // Convert the final merged PO to MO
                        match PoConverter::convert_po_to_mo(&final_merged_po, &output_mo_path) {
                            Ok(_) => {
                                // è·å–è¾“å‡ºç›®å½•ç”¨äºæ—¥å¿—æ˜¾ç¤º
                                let output_dir = output_mo_path.parent()
                                    .map_or_else(|| "[æœªçŸ¥ç›®å½•]".to_string(), 
                                               |dir| dir.to_string_lossy().to_string());
                                let file_name = output_mo_path.file_name()
                                    .map_or_else(|| "[æœªçŸ¥æ–‡ä»¶]".to_string(), 
                                               |name| name.to_string_lossy().to_string());
                                self.state.add_log(&format!("åˆå¹¶å®Œæˆ! æ–°MOæ–‡ä»¶å·²ä¿å­˜åˆ°: {}/{}", output_dir, file_name));
                            },
                            Err(e) => {
                                self.state.add_log(&format!("å°†åˆå¹¶åçš„POè½¬æ¢ä¸ºMOå¤±è´¥: {}", e));
                            }
                        }
                    },
                    Err(e) => {
                        self.state.add_log(&format!("æœ€ç»ˆPOæ–‡ä»¶åˆå¹¶å¤±è´¥: {}", e));
                    }
                }
            },
            Err(e) => {
                self.state.add_log(&format!("å°†ä¸»MOæ–‡ä»¶è½¬æ¢ä¸ºPOå¤±è´¥: {}", e));
            }
        }
    }

    // åˆ›å»ºé»˜è®¤çš„è¾“å‡ºç›®å½•ï¼ˆæ¡Œé¢ä¸Šçš„"BLMMå¯¼å‡º"æ–‡ä»¶å¤¹ï¼‰
    fn create_default_output_directory(&mut self) -> Option<PathBuf> {
        // è·å–æ¡Œé¢è·¯å¾„
        let desktop_dir = dirs::desktop_dir()?;
        let default_output_dir = desktop_dir.join("BLMMå¯¼å‡º");
        
        // å°è¯•åˆ›å»ºç›®å½•
        match std::fs::create_dir_all(&default_output_dir) {
            Ok(_) => {
                self.state.add_log(&format!("å·²åˆ›å»ºé»˜è®¤è¾“å‡ºç›®å½? {}", default_output_dir.to_string_lossy()));
                Some(default_output_dir)
            },
            Err(e) => {
                self.state.add_log(&format!("åˆ›å»ºé»˜è®¤è¾“å‡ºç›®å½•å¤±è´¥: {}", e));
                None
            }
        }
    }

    // Restore the refresh_mods_list function
    #[allow(dead_code)]
    fn refresh_mods_list(&mut self) {
        self.scan_mods_directory();
    }

    fn render_install_dialog(&mut self, ctx: &egui::Context) {
        if self.show_install_dialog {
            egui::Window::new("å®‰è£…")
                .collapsible(false)
                .show(ctx, |ui| {
                    ui.horizontal(|ui| {
                        if ui.button("ğŸ“").clicked() {
                            if let Some(path) = rfd::FileDialog::new()
                                .set_title("Choose Download Directory")
                                .pick_folder() {
                                self.install_path = path.display().to_string();
                            }
                        }
                        ui.text_edit_singleline(&mut self.install_path);
                    });

                    egui::ScrollArea::vertical().show(ui, |ui| {
                        let file_types = ["girly_animation_pack_v107_switch.bnp", 
                                         "grav boosters-6816-2-0-1-1702399400.zip",
                                         "hyliapack.bnp", 
                                         "Legendary Modification-1379-1-0-2-1697809243.7z"];
                                         
                        for file in file_types {
                            ui.horizontal(|ui| {
                                ui.checkbox(&mut false, "");
                                ui.label(file);
                            });
                        }
                    });

                    if ui.button("å…³é—­").clicked() {
                        self.show_install_dialog = false;
                    }
                });
        }
    }

    fn render_package_tab(&mut self, ui: &mut Ui) {
        ui.heading("è¯­è¨€åŒ…ç®¡ç?);
        
        ui.horizontal(|ui| {
            if ui.button("æµè§ˆå¯ç”¨è¯­è¨€åŒ?).clicked() {
                // This would connect to a repository or show local packages
            }
            
            if ui.button("æ›´æ–°è¯­è¨€åŒ…åˆ—è¡?).clicked() {
                // This would refresh available packages
            }
        });
        
        ui.separator();
        
        ui.label("æ²¡æœ‰å¯ç”¨çš„è¯­è¨€åŒ…ã€‚è¯·æ›´æ–°è¯­è¨€åŒ…åˆ—è¡¨æˆ–æ£€æŸ¥ç½‘ç»œè¿æ¥ã€?);
    }

    fn render_mod_settings(&mut self, ui: &mut Ui) {
        // è·å–ä¸»é¢˜çš„å¼ºè°ƒè‰²
        let accent_color = crate::models::ThemeManager::get_accent_color(&self.config.theme);
        
        ui.heading(RichText::new("è®¾ç½®").color(accent_color));
        
        // ä¿å­˜åŸå§‹é…ç½®å€¼ï¼Œä»¥æ£€æµ‹æ›´æ”?        let orig_main_mo_file = self.state.main_mo_file.clone();
        let orig_dark_mode = self.state.dark_mode;
        let orig_auto_batch = self.state.auto_batch;
        let orig_auto_close = self.state.auto_close;
        let orig_show_logs = self.state.show_logs;
        let orig_ignore_main_mo_entries = self.state.ignore_main_mo_entries;
        let orig_theme = self.config.theme.clone();
        
        // æ·»åŠ ä¸»é¢˜è®¾ç½®éƒ¨åˆ†
        ui.collapsing("ç•Œé¢ä¸»é¢˜", |ui| {
            let theme_names = crate::models::ThemeManager::get_theme_names();
            
            // ç»˜åˆ¶ä¸»é¢˜é€‰æ‹©æŒ‰é’®
            ui.horizontal_wrapped(|ui| {
                for (name, theme) in theme_names {
                    // è®¾ç½®æŒ‰é’®æ ·å¼
                    let mut button = egui::Button::new(name);
                    
                    // æ ¹æ®ä¸»é¢˜ç±»å‹è®¾ç½®ä¸åŒçš„æŒ‰é’®é¢œè‰?                    if self.config.theme == theme {
                        button = button.fill(crate::models::ThemeManager::get_accent_color(&theme));
                    }
                    
                    // æ·»åŠ æŒ‰é’®å¹¶å¤„ç†ç‚¹å‡»äº‹ä»?                    if ui.add(button).clicked() {
                        self.config.theme = theme.clone();
                        self.state.dark_mode = self.config.theme != crate::models::AppTheme::Light 
                            && self.config.theme != crate::models::AppTheme::Sepia;
                    }
                }
            });
        });
        
        ui.separator();
        
        // ä¸»MOæ–‡ä»¶è®¾ç½®éƒ¨åˆ†
        ui.heading("åŸºç¡€MOæ–‡ä»¶");
        
        ui.horizontal(|ui| {
            ui.label("ä¸»MOæ–‡ä»¶:");
            
            if let Some(mo_file) = &self.state.main_mo_file {
                // æ˜¾ç¤ºæ–‡ä»¶å?                let file_name = mo_file.file_name()
                    .map(|f| f.to_string_lossy().to_string())
                    .unwrap_or_else(|| mo_file.display().to_string());
                let response = ui.label(file_name);
                
                // æ‚¬åœæ—¶æ˜¾ç¤ºå®Œæ•´è·¯å¾?                let full_path = mo_file.to_string_lossy().to_string();
                response.on_hover_text(full_path);
            } else {
                ui.label("[æœªè®¾ç½®]");
            }
            
            if ui.button("é€‰æ‹©MOæ–‡ä»¶").clicked() {
                if let Some(mo_path) = rfd::FileDialog::new()
                    .add_filter("MOæ–‡ä»¶", &["mo"])
                    .set_title("é€‰æ‹©Blenderçš„moæ–‡ä»¶")
                    .pick_file() {
                    
                    // ä¿å­˜ä¸»MOæ–‡ä»¶è·¯å¾„
                    self.state.main_mo_file = Some(mo_path.clone());
                    self.config.main_mo_file = Some(mo_path.clone());
                    
                    // æ¸…é™¤åˆå¹¶ç¼“å­˜ï¼Œå› ä¸ºä¸»MOæ–‡ä»¶å·²æ›´æ”?                    self.state.cached_merged_po = None;
                    self.state.needs_remerge = true;
                    
                    // æ·»åŠ æ—¥å¿—
                    self.state.add_log(&format!("å·²è®¾ç½®ä¸»MOæ–‡ä»¶: {}", mo_path.display()));
                }
            }
            
            if ui.button("è‡ªåŠ¨æŸ¥æ‰¾").clicked() {
                self.auto_locate_blender_mo_file();
            }
            
            if ui.button("æ¸…é™¤").clicked() {
                self.state.main_mo_file = None;
                self.config.main_mo_file = None;
                
                // æ¸…é™¤åˆå¹¶ç¼“å­˜ï¼Œå› ä¸ºä¸»MOæ–‡ä»¶å·²æ›´æ”?                self.state.cached_merged_po = None;
                self.state.needs_remerge = true;
                
                self.state.add_log("å·²æ¸…é™¤ä¸»MOæ–‡ä»¶è®¾ç½®");
            }
        });
        
        // æ·»åŠ å¯¼å‡ºåŸºç¡€MOæ–‡ä»¶çš„æŒ‰é’®å’Œè¯´æ˜
        ui.horizontal(|ui| {
            if ui.button("å¯¼å‡ºåŸºç¡€æ–‡ä»¶").clicked() {
                self.export_base_mo_file();
            }
            ui.label("(å°†å½“å‰çš„åŸºç¡€MOæ–‡ä»¶å¯¼å‡ºä¸ºç‹¬ç«‹æ–‡ä»¶ï¼Œä¸åšä»»ä½•åˆå¹¶)");
        });
        
        ui.add_space(4.0);
        
        ui.horizontal(|ui| {
            ui.label("ä¸»MOæ–‡ä»¶æè¿°:").on_hover_text("ä¸»MOæ–‡ä»¶æ˜¯Blenderçš„åŸå§‹ç¿»è¯‘æ–‡ä»¶ï¼Œé€šå¸¸ä½äºBlenderå®‰è£…ç›®å½•çš?datafiles/locale/zh_CN/LC_MESSAGES/'ä¸‹ï¼Œåä¸º'blender.mo'");
        });
        
        ui.separator();
        
        // è¾“å‡ºç›®å½•è®¾ç½®éƒ¨åˆ†
        ui.heading("è¾“å‡ºè®¾ç½®");
        
        ui.horizontal(|ui| {
            ui.label("è¾“å‡ºç›®å½•:");
            
            if let Some(output_dir) = &self.state.output_directory {
                // æ˜¾ç¤ºç›®å½•å?                let dir_name = output_dir.display().to_string();
                let response = ui.label(dir_name);
                
                // æ‚¬åœæ—¶æ˜¾ç¤ºå®Œæ•´è·¯å¾?                let full_path = output_dir.to_string_lossy().to_string();
                response.on_hover_text(full_path);
            } else {
                ui.label("[æœªè®¾ç½?- å°†ä½¿ç”¨æ¡Œé¢ä¸Šçš„\"BLMMå¯¼å‡º\"æ–‡ä»¶å¤¹]");
            }
            
            if ui.button("é€‰æ‹©è¾“å‡ºç›®å½•").clicked() {
                if let Some(dir) = rfd::FileDialog::new()
                    .set_title("é€‰æ‹©è¾“å‡ºç›®å½•")
                    .pick_folder() {
                        self.state.output_directory = Some(dir.clone());
                        self.config.output_directory = Some(dir.clone());
                        self.state.add_log(&format!("å·²è®¾ç½®è¾“å‡ºç›®å½? {}", dir.display()));
                    }
            }
            
            if ui.button("æ¸…é™¤").clicked() {
                self.state.output_directory = None;
                self.config.output_directory = None;
                self.state.add_log("å·²æ¸…é™¤è¾“å‡ºç›®å½•è®¾ç½®ï¼Œå°†ä½¿ç”¨æ¡Œé¢ä¸Šçš„\"BLMMå¯¼å‡º\"æ–‡ä»¶å¤?);
            }
        });
        
        // æ·»åŠ é»˜è®¤è¾“å‡ºç›®å½•è¯´æ˜
        ui.add_space(4.0);
        ui.label("æç¤º: æœªè®¾ç½®è¾“å‡ºç›®å½•æ—¶ï¼Œå°†é»˜è®¤åœ¨æ¡Œé¢ä¸Šåˆ›å»º\"BLMMå¯¼å‡º\"æ–‡ä»¶å¤¹ï¼Œå¹¶å°†åˆå¹¶åçš„MOæ–‡ä»¶ä¿å­˜åˆ°æ­¤å¤„ã€?);
        
        ui.separator();
        
        // å¸¸ç”¨è®¾ç½®éƒ¨åˆ†
        ui.heading("å¸¸ç”¨è®¾ç½®");
        
        ui.horizontal(|ui| {
            ui.checkbox(&mut self.state.auto_batch, "è‡ªåŠ¨æ‰¹å¤„ç?);
            ui.checkbox(&mut self.state.auto_close, "å¤„ç†å®Œæˆåå…³é—?);
        });
        
        ui.checkbox(&mut self.state.show_logs, "æ˜¾ç¤ºæ—¥å¿—çª—å£");
        
        // é«˜çº§è®¾ç½®éƒ¨åˆ†
        ui.collapsing("é«˜çº§è®¾ç½®", |ui| {
            // æ–°å¢é€‰é¡¹: å¿½ç•¥ä¸»MOåˆå¹¶
            ui.checkbox(&mut self.state.ignore_main_mo_entries, "å¿½ç•¥ä¸»moåˆå¹¶")
                .on_hover_text("å¯ç”¨åï¼Œè¯­è¨€åŒ…ä¸­ä¸ä¸»MOæ–‡ä»¶é‡å¤çš„æ¡ç›®å°†è¢«å¿½ç•¥ï¼Œä¿ç•™ä¸»MOæ–‡ä»¶ä¸­çš„åŸå§‹ç¿»è¯‘");
            
            ui.horizontal(|ui| {
                ui.label(format!("çº¿ç¨‹æ±? {} çº¿ç¨‹", num_cpus::get()));
            });
        });
        
        // æ£€æŸ¥é…ç½®æ˜¯å¦æœ‰å˜æ›´ï¼Œå¦‚æœæœ‰åˆ™ä¿å­?        if orig_main_mo_file != self.state.main_mo_file ||
           orig_dark_mode != self.state.dark_mode ||
           orig_auto_batch != self.state.auto_batch ||
           orig_auto_close != self.state.auto_close ||
           orig_show_logs != self.state.show_logs ||
           orig_ignore_main_mo_entries != self.state.ignore_main_mo_entries ||
           orig_theme != self.config.theme {
            // ä¿å­˜è®¾ç½®åˆ°é…ç½®æ–‡ä»?            self.config.main_mo_file = self.state.main_mo_file.clone();
            self.config.dark_mode = self.state.dark_mode;
            self.config.auto_batch = self.state.auto_batch;
            self.config.auto_close = self.state.auto_close;
            self.config.show_logs = self.state.show_logs;
            self.config.ignore_main_mo_entries = self.state.ignore_main_mo_entries;
            
            if let Err(e) = self.config.save() {
                self.state.add_log(&format!("æ— æ³•ä¿å­˜é…ç½®: {}", e));
            }
        }
    }

    // å®‰è£…æ–°è¯­è¨€åŒ?    fn install_new_mod(&mut self) {
        // è·å–æˆ–åˆ›å»ºMODç¼“å­˜ç›®å½•
        let mods_dir = self.get_or_create_mods_cache_dir();
        if mods_dir.is_none() {
            self.state.add_log("é”™è¯¯: æ— æ³•åˆ›å»ºè¯­è¨€åŒ…ç¼“å­˜ç›®å½?);
            return;
        }
        
        let mods_dir = mods_dir.unwrap();
        
        // è‡ªåŠ¨è®¾ç½®mods_directoryåˆ°å›ºå®šçš„ç¼“å­˜ç›®å½•
        self.state.mods_directory = Some(mods_dir.clone());
        self.config.mods_directory = Some(mods_dir.clone());
        
        // æ‰“å¼€æ–‡ä»¶é€‰æ‹©å¯¹è¯æ¡†ï¼Œå…è®¸å¤šé€‰ï¼ŒåŒæ—¶æ”¯æŒPOå’ŒCSVæ–‡ä»¶
        if let Some(files) = rfd::FileDialog::new()
            .add_filter("ç¿»è¯‘æ–‡ä»¶", &["po", "csv"])
            .add_filter("POæ–‡ä»¶", &["po"])
            .add_filter("CSVæ–‡ä»¶", &["csv"])
            .set_title("é€‰æ‹©è¦å®‰è£…çš„ç¿»è¯‘æ–‡ä»¶")
            .pick_files() {
                
            let files_count = files.len();
            self.state.add_log(&format!("é€‰æ‹©äº?{} ä¸ªç¿»è¯‘æ–‡ä»¶å‡†å¤‡å®‰è£?, files_count));
            
            // è®°å½•æˆåŠŸå®‰è£…çš„æ–‡ä»¶æ•°é‡?            let mut success_count = 0;
            
            // åˆ›å»ºä¸´æ—¶ç¼“å­˜ç›®å½•ç”¨äºCSVè½¬æ¢
            let cache_dir = if let Some(local_dir) = dirs::data_local_dir() {
                local_dir.join("BLMM").join("cache")
            } else {
                std::env::temp_dir().join("BLMM").join("cache")
            };
            
            // ç¡®ä¿ç¼“å­˜ç›®å½•å­˜åœ¨
            if let Err(e) = std::fs::create_dir_all(&cache_dir) {
                self.state.add_log(&format!("åˆ›å»ºç¼“å­˜ç›®å½•å¤±è´¥: {}", e));
                return;
            }
            
            // å¤„ç†æ¯ä¸€ä¸ªé€‰æ‹©çš„æ–‡ä»?            for file in files {
                // ç¡®å®šæ–‡ä»¶ç±»å‹
                let file_ext = file.extension().unwrap_or_default().to_string_lossy().to_lowercase();
                
                // å¯¹äºCSVæ–‡ä»¶ï¼Œå…ˆè½¬æ¢ä¸ºPO
                let processed_file = if file_ext == "csv" {
                    self.state.add_log(&format!("æ£€æµ‹åˆ°CSVæ–‡ä»¶: {}", file.display()));
                    
                    // ç”Ÿæˆä¸´æ—¶POæ–‡ä»¶
                    let temp_po_path = cache_dir.join(format!("temp_{}.po", SystemTime::now()
                        .duration_since(std::time::UNIX_EPOCH)
                        .unwrap_or_default()
                        .as_secs()));
                    
                    // è½¬æ¢CSVåˆ°PO
                    match CsvConverter::convert_csv_to_po(&file, &temp_po_path) {
                        Ok(_) => {
                            self.state.add_log(&format!("æˆåŠŸå°†CSVè½¬æ¢ä¸ºPO: {}", temp_po_path.display()));
                            temp_po_path
                        },
                        Err(e) => {
                            self.state.add_log(&format!("CSVè½¬æ¢ä¸ºPOå¤±è´¥: {}", e));
                            continue;  // è·³è¿‡æ­¤æ–‡ä»?                        }
                    }
                } else {
                    file.clone()
                };
                
                // åˆ›å»ºæ–°çš„MODä¿¡æ¯
                let orig_file_name = file.file_name().unwrap_or_default().to_string_lossy().to_string();
                let mut file_name = processed_file.file_name().unwrap_or_default().to_string_lossy().to_string();
                
                // å¦‚æœæ˜¯ä»CSVè½¬æ¢çš„POï¼Œç»™æ–‡ä»¶ååŠ ä¸Šæ ‡è®?                if file_ext == "csv" {
                    let stem = orig_file_name.strip_suffix(".csv").unwrap_or(&orig_file_name);
                    file_name = format!("{}_from_csv.po", stem);
                }
                
                // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨åŒåè¯­è¨€åŒ…ï¼Œå¦‚æœå­˜åœ¨åˆ™æ·»åŠ?new"åç¼€
                let mut counter = 0;
                let original_name = file_name.clone();
                let stem = if let Some(pos) = original_name.rfind('.') {
                    &original_name[0..pos]
                } else {
                    &original_name
                };
                let ext = if let Some(pos) = original_name.rfind('.') {
                    &original_name[pos..]
                } else {
                    ""
                };
                
                // æ£€æŸ¥åç§°æ˜¯å¦å·²å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨åˆ™æ·»åŠ "new"åç¼€
                while self.state.installed_mods.iter().any(|m| m.name == file_name) || mods_dir.join(&file_name).exists() {
                    counter += 1;
                    if counter == 1 {
                        file_name = format!("{}new{}", stem, ext);
                    } else {
                        file_name = format!("{}new{}{}", stem, counter, ext);
                    }
                }
                
                let mut mod_info = ModInfo::default();
                mod_info.name = file_name.clone();
                mod_info.status = ModStatus::Enabled; // é»˜è®¤ä¸ºå¯ç”¨çŠ¶æ€?                mod_info.install_date = Some(Local::now());
                
                // å¦‚æœæ¥è‡ªCSVï¼Œæ·»åŠ æè¿?                if file_ext == "csv" {
                    mod_info.description = Some("ä»CSVè½¬æ¢çš„POæ–‡ä»¶".to_string());
                }
                
                // å°†POæ–‡ä»¶å¤åˆ¶åˆ°MODç›®å½•
                let target_path = mods_dir.join(&file_name);
                
                // å°è¯•å¤åˆ¶æ–‡ä»¶
                match std::fs::copy(&processed_file, &target_path) {
                    Ok(_) => {
                        mod_info.path = target_path;
                        
                        // åœ¨é…ç½®ä¸­ä¿å­˜è¯¥modçš„å¯ç”¨çŠ¶æ€?                        self.config.saved_mods.insert(file_name.clone(), true);
                        
                        self.state.installed_mods.push(mod_info);
                        
                        // æ ‡è®°éœ€è¦é‡æ–°åˆå¹?                        self.state.needs_remerge = true;
                        
                        // å¦‚æœæ–‡ä»¶åè¢«ä¿®æ”¹ï¼Œæ·»åŠ ç›¸åº”æ—¥å¿?                        if file_name != original_name {
                            self.state.add_log(&format!("æ£€æµ‹åˆ°åŒåè¯­è¨€åŒ…ï¼Œå·²é‡å‘½åä¸? {}", file_name));
                        }
                        
                        // æ˜¾ç¤ºæˆåŠŸä¿¡æ¯ï¼ŒåŒºåˆ†CSVå’ŒPO
                        if file_ext == "csv" {
                            self.state.add_log(&format!("æˆåŠŸå°†CSVæ–‡ä»¶è½¬æ¢å¹¶å®‰è£…ä¸ºè¯­è¨€åŒ? {}", file_name));
                        } else {
                            self.state.add_log(&format!("æˆåŠŸå®‰è£…è¯­è¨€åŒ? {}", file_name));
                        }
                        
                        success_count += 1;
                        
                        // å¦‚æœæ˜¯ä¸´æ—¶æ–‡ä»¶ï¼Œå®‰è£…ååˆ é™?                        if file_ext == "csv" {
                            let _ = std::fs::remove_file(&processed_file);
                        }
                    },
                    Err(e) => {
                        let file_display = file.file_name().unwrap_or_default().to_string_lossy();
                        self.state.add_log(&format!("è¯­è¨€åŒ?{} å®‰è£…å¤±è´¥: {}", file_display, e));
                        
                        // å¦‚æœæ˜¯ä¸´æ—¶æ–‡ä»¶ï¼Œå®‰è£…å¤±è´¥ä¹Ÿè¦åˆ é™¤
                        if file_ext == "csv" {
                            let _ = std::fs::remove_file(&processed_file);
                        }
                    }
                }
            }
            
            // å®‰è£…å®Œæˆåæ›´æ–°é…ç½®å¹¶æ˜¾ç¤ºæ±‡æ€»ä¿¡æ?            if success_count > 0 {
                // ä¿å­˜é…ç½®
                self.config.save().ok();
                
                // å¦‚æœå®‰è£…äº†å¤šä¸ªæ–‡ä»¶ï¼Œæ˜¾ç¤ºæ±‡æ€»ä¿¡æ?                if files_count > 1 {
                    self.state.add_log(&format!("æ‰¹é‡å®‰è£…å®Œæˆï¼šæˆåŠ?{}/{}ä¸ªè¯­è¨€åŒ?, success_count, files_count));
                }
            }
        }
    }
    
    // æ‰«æMODç›®å½•
    fn scan_mods_directory(&mut self) {
        // è·å–æˆ–åˆ›å»ºMODç¼“å­˜ç›®å½•
        let mods_dir = self.get_or_create_mods_cache_dir();
        if mods_dir.is_none() {
            self.state.add_log("é”™è¯¯: æ— æ³•åˆ›å»ºè¯­è¨€åŒ…ç¼“å­˜ç›®å½?);
            return;
        }
        
        let mods_dir = mods_dir.unwrap();
        
        // è‡ªåŠ¨è®¾ç½®mods_directoryåˆ°å›ºå®šçš„ç¼“å­˜ç›®å½•
        self.state.mods_directory = Some(mods_dir.clone());
        self.config.mods_directory = Some(mods_dir.clone());
        
        // æ¸…ç©ºå½“å‰MODåˆ—è¡¨
        self.state.installed_mods.clear();
        
        // æ‰«æç›®å½•ä¸‹çš„æ‰€æœ‰POæ–‡ä»¶
        match std::fs::read_dir(&mods_dir) {
            Ok(entries) => {
                let mut found = false;
                
                for entry in entries {
                    if let Ok(entry) = entry {
                        let path = entry.path();
                        
                        // æ£€æŸ¥æ˜¯å¦ä¸ºPOæ–‡ä»¶
                        if path.is_file() && path.extension().map_or(false, |e| e == "po") {
                            found = true;
                            
                            // åˆ›å»ºMODä¿¡æ¯
                            let file_name = path.file_name().unwrap_or_default().to_string_lossy().to_string();
                            let mut mod_info = ModInfo::default();
                            mod_info.name = file_name.clone();
                            mod_info.path = path;
                            
                            // ä»é…ç½®ä¸­åŠ è½½è¯¥modçš„å¯ç”¨çŠ¶æ€?                            if let Some(enabled) = self.config.saved_mods.get(&file_name) {
                                mod_info.status = if *enabled {
                                    ModStatus::Enabled
                                } else {
                                    ModStatus::Disabled
                                };
                            } else {
                                // å¦‚æœæ²¡æœ‰ä¿å­˜çš„çŠ¶æ€ï¼Œé»˜è®¤ä¸ºå¯ç”?                                mod_info.status = ModStatus::Enabled;
                            }
                            
                            // è·å–æ–‡ä»¶ä¿¡æ¯
                            if let Ok(metadata) = std::fs::metadata(&mod_info.path) {
                                // å°è¯•è·å–å®‰è£…æ—¥æœŸï¼ˆåŸºäºæ–‡ä»¶åˆ›å»ºæ—¶é—´ï¼‰
                                if let Ok(created) = metadata.created() {
                                    if let Ok(duration) = created.duration_since(UNIX_EPOCH) {
                                        mod_info.install_date = Local.timestamp_opt(duration.as_secs() as i64, 0).single();
                                    }
                                }
                            }
                            
                            // æ·»åŠ åˆ°MODåˆ—è¡¨
                            self.state.installed_mods.push(mod_info);
                        }
                    }
                }
                
                if found {
                    self.state.add_log(&format!("æ‰«æå®Œæˆï¼Œå‘ç?{} ä¸ªè¯­è¨€åŒ?, self.state.installed_mods.len()));
                } else {
                    self.state.add_log("æœªåœ¨ç›®å½•ä¸­æ‰¾åˆ°ä»»ä½•POè¯­è¨€åŒ?);
                }
                
                // ä¿å­˜é…ç½®
                self.config.save().ok();
            },
            Err(e) => {
                self.state.add_log(&format!("æ‰«æè¯­è¨€åŒ…ç›®å½•å¤±è´? {}", e));
            }
        }
    }
    
    // å¯ç”¨MOD
    fn enable_mod(&mut self, index: usize) {
        if index < self.state.installed_mods.len() {
            self.state.installed_mods[index].status = ModStatus::Enabled;
            let mod_name = &self.state.installed_mods[index].name;
            
            // åœ¨é…ç½®ä¸­ä¿å­˜è¯¥modçš„å¯ç”¨çŠ¶æ€?            self.config.saved_mods.insert(mod_name.clone(), true);
            self.config.save().ok();
            
            // æ ‡è®°éœ€è¦é‡æ–°åˆå¹?            self.state.needs_remerge = true;
            
            self.state.add_log(&format!("å·²å¯ç”¨è¯­è¨€åŒ? {}", mod_name));
        }
    }
    
    // ç¦ç”¨MOD
    fn disable_mod(&mut self, index: usize) {
        if index < self.state.installed_mods.len() {
            self.state.installed_mods[index].status = ModStatus::Disabled;
            let mod_name = &self.state.installed_mods[index].name;
            
            // åœ¨é…ç½®ä¸­ä¿å­˜è¯¥modçš„ç¦ç”¨çŠ¶æ€?            self.config.saved_mods.insert(mod_name.clone(), false);
            self.config.save().ok();
            
            // æ ‡è®°éœ€è¦é‡æ–°åˆå¹?            self.state.needs_remerge = true;
            
            self.state.add_log(&format!("å·²ç¦ç”¨è¯­è¨€åŒ? {}", mod_name));
        }
    }
    
    // å¸è½½MOD
    fn uninstall_mod(&mut self, index: usize) {
        if index < self.state.installed_mods.len() {
            let mod_info = &self.state.installed_mods[index];
            let mod_name = mod_info.name.clone();
            
            // å°è¯•åˆ é™¤æ–‡ä»¶
            match std::fs::remove_file(&mod_info.path) {
                Ok(_) => {
                    // ä»é…ç½®ä¸­ç§»é™¤è¯¥modçš„çŠ¶æ€è®°å½?                    self.config.saved_mods.remove(&mod_name);
                    self.config.save().ok();
                    
                    self.state.installed_mods.remove(index);
                    
                    // æ ‡è®°éœ€è¦é‡æ–°åˆå¹?                    self.state.needs_remerge = true;
                    
                    self.state.add_log(&format!("å·²å¸è½½è¯­è¨€åŒ? {}", mod_name));
                },
                Err(e) => {
                    self.state.add_log(&format!("å¸è½½è¯­è¨€åŒ…å¤±è´? {}", e));
                }
            }
        }
    }

    // åº”ç”¨é€€å‡ºæ—¶ä¿å­˜é…ç½®
    fn save_config_on_exit(&mut self) {
        // ç¡®ä¿é…ç½®å¯¹è±¡åŒ…å«æœ€æ–°çš„çŠ¶æ€?        self.config.main_mo_file = self.state.main_mo_file.clone();
        self.config.mods_directory = self.state.mods_directory.clone();
        self.config.output_directory = self.state.output_directory.clone();
        
        // ä¿æŒå‘åå…¼å®¹çš„dark_modeè®¾ç½®
        self.config.dark_mode = self.state.dark_mode;
        
        self.config.auto_batch = self.state.auto_batch;
        self.config.auto_close = self.state.auto_close;
        self.config.show_logs = self.state.show_logs;
        self.config.ignore_main_mo_entries = self.state.ignore_main_mo_entries;
        
        // ä¿å­˜é…ç½®
        if let Err(e) = self.config.save() {
            self.state.add_log(&format!("é€€å‡ºæ—¶ä¿å­˜é…ç½®å¤±è´¥: {}", e));
        } else {
            self.state.add_log("é…ç½®å·²ä¿å­?);
        }
    }

    // å°†ä¸»MOæ–‡ä»¶å¤åˆ¶åˆ°BLMMç›®å½•
    fn clone_main_mo_to_blmm(&mut self, original_mo_path: &PathBuf) -> Option<PathBuf> {
        use std::fs;

        // è·å–BLMMç¼“å­˜ç›®å½•
        let blmm_dir = if let Some(local_dir) = dirs::data_local_dir() {
            local_dir.join("BLMM")
        } else {
            // å¦‚æœæ— æ³•è·å–ç³»ç»Ÿæœ¬åœ°æ•°æ®ç›®å½•ï¼Œä½¿ç”¨ä¸´æ—¶ç›®å½?            std::env::temp_dir().join("BLMM")
        };

        // ç¡®ä¿ç›®å½•å­˜åœ¨
        if let Err(e) = fs::create_dir_all(&blmm_dir) {
            self.state.add_log(&format!("åˆ›å»ºBLMMç›®å½•å¤±è´¥: {}", e));
            return None;
        }

        // ä¸ºMOæ–‡ä»¶åˆ›å»ºä¸€ä¸ªæ–°çš„è·¯å¾?        // ä¸å†éœ€è¦åŸå§‹æ–‡ä»¶åï¼Œç›´æ¥ä½¿ç”¨å›ºå®šåç§?        let blmm_mo_path = blmm_dir.join("base_blender.mo");

        // å¤åˆ¶æ–‡ä»¶
        match fs::copy(original_mo_path, &blmm_mo_path) {
            Ok(_) => {
                self.state.add_log(&format!("å·²å°†ä¸»MOæ–‡ä»¶å¤åˆ¶åˆ°BLMMç›®å½•: {}", blmm_mo_path.display()));
                Some(blmm_mo_path)
            },
            Err(e) => {
                self.state.add_log(&format!("å¤åˆ¶ä¸»MOæ–‡ä»¶åˆ°BLMMç›®å½•å¤±è´¥: {}", e));
                None
            }
        }
    }

    // åœ¨process_conversion_resultsæ–¹æ³•åæ·»åŠ æ–°çš„æ–¹æ³•å¤„ç†åˆå¹¶è¿›åº?    fn process_merge_status(&mut self) {
        // æ›´æ–°åŠ¨ç”»è®¡æ•°å™?        if self.state.is_merging {
            self.state.merge_progress_anim += 1;
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰æ¥è‡ªåˆå¹¶çº¿ç¨‹çš„æ¶ˆæ?        if let Ok(status) = self.merge_rx.try_recv() {
            match status {
                MergeStatus::Started => {
                    self.state.add_log("å¼€å§‹åˆå¹¶POæ–‡ä»¶...");
                },
                MergeStatus::Progress(progress) => {
                    self.state.merge_progress = progress;
                    self.state.add_log(&format!("åˆå¹¶è¿›åº¦: {}%", (progress * 100.0) as i32));
                },
                MergeStatus::Completed(cached_path) => {
                    self.state.is_merging = false;
                    self.state.merge_progress = 1.0;
                    self.state.cached_merged_po = Some(cached_path.clone());
                    self.state.needs_remerge = false;
                    self.state.add_log(&format!("POæ–‡ä»¶åˆå¹¶æˆåŠŸï¼Œå·²ç”Ÿæˆç¼“å­˜æ–‡ä»¶: {}", cached_path.display()));
                    self.state.add_log("ç‚¹å‡»'åº”ç”¨åˆ°MOæ–‡ä»¶'å°†åˆå¹¶ç»“æœåº”ç”¨åˆ°ä¸»MOæ–‡ä»¶");
                    
                    // å¦‚æœç¼“å­˜æ–‡ä»¶å¯ç”¨ï¼Œåˆ™è‡ªåŠ¨åº”ç”¨åˆ°MOæ–‡ä»¶
                    if self.state.cached_merged_po.is_some() {
                        self.apply_merged_po_to_mo();
                    }
                },
                MergeStatus::Failed(error) => {
                    self.state.is_merging = false;
                    self.state.add_log(&format!("åˆå¹¶å¤±è´¥: {}", error));
                }
            }
        }
    }

    // ä¸“é—¨ç”¨äºæ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯çš„å‡½æ•?    fn show_help_window(&mut self, ctx: &egui::Context) {
        if self.state.show_help {
            egui::Window::new("ä½¿ç”¨å¸®åŠ©")
                .collapsible(false)
                .min_width(500.0)
                .show(ctx, |ui| {
                    ui.heading("Blenderå­—å…¸åˆå¹¶ç®¡ç†å™?By:å‡Œå·é›?);
                    ui.label("ä½¿ç”¨å¸®åŠ©");
                    ui.separator();
                    
                    ui.collapsing("åŸºæœ¬ä½¿ç”¨æµç¨‹", |ui| {
                        ui.add_space(5.0);
                        
                        ui.label("1. è®¾ç½® - é€‰æ‹©ä¸»MOæ–‡ä»¶å’Œè¯­è¨€åŒ…ç›®å½?);
                        ui.label("   - è¿›å…¥è®¾ç½®é€‰é¡¹å¡ï¼Œè®¾ç½®Blenderçš„ä¸»MOæ–‡ä»¶");
                        ui.label("   - è®¾ç½®å­˜æ”¾POè¯­è¨€åŒ…çš„ç›®å½•");
                        ui.add_space(5.0);
                        
                        ui.label("2. å®‰è£…è¯­è¨€åŒ?);
                        ui.label("   - ç‚¹å‡»ã€Œå®‰è£…è¯­è¨€åŒ…ã€æŒ‰é’®é€‰æ‹©POæ–‡ä»¶");
                        ui.label("   - å®‰è£…åè¯­è¨€åŒ…ä¼šè‡ªåŠ¨å¯ç”¨");
                        ui.add_space(5.0);
                        
                        ui.label("3. ç®¡ç†è¯­è¨€åŒ?);
                        ui.label("   - å‹¾é€?å–æ¶ˆå‹¾é€‰è¯­è¨€åŒ…ä»¥å¯ç”¨/ç¦ç”¨");
                        ui.label("   - ä½¿ç”¨â–²â–¼æŒ‰é’®è°ƒæ•´è¯­è¨€åŒ…ä¼˜å…ˆçº§");
                        ui.label("   - ä¼˜å…ˆçº§é«˜çš„è¯­è¨€åŒ…ç¿»è¯‘ä¼šè¦†ç›–ä¼˜å…ˆçº§ä½çš„ç¿»è¯?);
                        ui.add_space(5.0);
                        
                        ui.label("4. åº”ç”¨æ›´æ”¹");
                        ui.label("   - ä¿®æ”¹è¯­è¨€åŒ…çŠ¶æ€åç‚¹å‡»ã€Œé‡æ–°åˆå¹¶ã€æŒ‰é’?);
                        ui.label("   - ç­‰å¾…å¤„ç†å®Œæˆåï¼Œå°†è‡ªåŠ¨åº”ç”¨åˆ°MOæ–‡ä»¶");
                    });
                    
                    ui.collapsing("é«˜çº§é€‰é¡¹", |ui| {
                        ui.label("- åœ¨è®¾ç½®ä¸­å¯å¯ç”¨ã€Œå¿½ç•¥ä¸»moåˆå¹¶ã€é€‰é¡¹ï¼Œä¿ç•™åŸå§‹MOç¿»è¯‘");
                        ui.label("- é€šè¿‡ä¸Šä¸‹ç§»åŠ¨è¯­è¨€åŒ…è°ƒæ•´ä¼˜å…ˆçº§ï¼Œé«˜ä¼˜å…ˆçº§çš„è¯­è¨€åŒ…ç¿»è¯‘ä¼šè¦†ç›–ä½ä¼˜å…ˆçº§çš?);
                        ui.label("- åº”ç”¨åˆ°MOæ–‡ä»¶åï¼Œéœ€è¦é‡å¯Blenderæ‰èƒ½çœ‹åˆ°æ›´æ”¹æ•ˆæœ");
                    });
                    
                    ui.collapsing("æ•…éšœæ’é™¤", |ui| {
                        ui.label("å¦‚æœåˆå¹¶å¤±è´¥:");
                        ui.label("1. æ£€æŸ¥ä¸»MOæ–‡ä»¶æ˜¯å¦å¯è¯»å†?);
                        ui.label("2. ç¡®ä¿è¯­è¨€åŒ…æ˜¯æ ‡å‡†çš„POæ ¼å¼");
                        ui.label("3. åœ¨æ—¥å¿—åŒºæŸ¥çœ‹è¯¦ç»†é”™è¯¯ä¿¡æ¯");
                        ui.label("4. å°è¯•å¯ç”¨æˆ–ç¦ç”¨ã€Œå¿½ç•¥ä¸»moåˆå¹¶ã€é€‰é¡¹");
                    });
                    
                    ui.separator();
                    
                    if ui.button("å…³é—­").clicked() {
                        self.state.show_help = false;
                    }
                });
        }
    }

    // é‡å‘½åå¯¹è¯æ¡†
    fn render_rename_dialog(&mut self, ctx: &egui::Context) {
        if self.state.rename_mod_index.is_some() {
            egui::Window::new("é‡å‘½åè¯­è¨€åŒ?)
                .collapsible(false)
                .show(ctx, |ui| {
                    ui.horizontal(|ui| {
                        ui.label("æ–°åç§?");
                        ui.text_edit_singleline(&mut self.state.rename_mod_name);
                    });
                    
                    ui.horizontal(|ui| {
                        if ui.button("ç¡®å®š").clicked() {
                            if let Some(index) = self.state.rename_mod_index {
                                self.rename_mod(index, self.state.rename_mod_name.clone());
                            }
                            self.state.rename_mod_index = None;
                        }
                        
                        if ui.button("å–æ¶ˆ").clicked() {
                            self.state.rename_mod_index = None;
                        }
                    });
                });
        }
    }
    
    // é‡å‘½åè¯­è¨€åŒ?    fn rename_mod(&mut self, index: usize, new_name: String) {
        if index >= self.state.installed_mods.len() || new_name.trim().is_empty() {
            return;
        }
        
        // è·å–è¯­è¨€åŒ…ç›®å½?        let mods_dir = match self.get_or_create_mods_cache_dir() {
            Some(dir) => dir,
            None => {
                self.state.add_log("é”™è¯¯: æ— æ³•è·å–è¯­è¨€åŒ…ç›®å½?);
                return;
            }
        };
        
        let mod_info = &mut self.state.installed_mods[index];
        let old_name = mod_info.name.clone();
        let old_path = mod_info.path.clone();
        
        // å¦‚æœæ–°åç§°ä¸æ—§åç§°ç›¸åŒï¼Œåˆ™ä¸åšä»»ä½•æ“ä½?        if old_name == new_name {
            return;
        }
        
        // ç¡®ä¿æ–°æ–‡ä»¶åä»?poç»“å°¾
        let new_name_with_ext = if new_name.to_lowercase().ends_with(".po") {
            new_name
        } else {
            format!("{}.po", new_name)
        };
        
        let new_path = mods_dir.join(&new_name_with_ext);
        
        // å°è¯•é‡å‘½åæ–‡ä»?        match std::fs::rename(&old_path, &new_path) {
            Ok(_) => {
                // æ›´æ–°æ¨¡ç»„ä¿¡æ¯
                mod_info.name = new_name_with_ext.clone();
                mod_info.path = new_path;
                
                // æ›´æ–°é…ç½®ä¸­çš„çŠ¶æ€è®°å½?                if let Some(is_enabled) = self.config.saved_mods.remove(&old_name) {
                    self.config.saved_mods.insert(new_name_with_ext.clone(), is_enabled);
                }
                
                // ä¿å­˜é…ç½®
                self.config.save().ok();
                
                self.state.add_log(&format!("è¯­è¨€åŒ…é‡å‘½åæˆåŠŸ: {} -> {}", old_name, new_name_with_ext));
                
                // æ ‡è®°éœ€è¦é‡æ–°åˆå¹?                self.state.needs_remerge = true;
            },
            Err(e) => {
                self.state.add_log(&format!("è¯­è¨€åŒ…é‡å‘½åå¤±è´¥: {}", e));
            }
        }
    }

    // è‡ªåŠ¨å®šä½Blenderä¸­æ–‡MOæ–‡ä»¶
    fn auto_locate_blender_mo_file(&mut self) {
        self.state.add_log("æ­£åœ¨è‡ªåŠ¨æœç´¢Blenderä¸­æ–‡MOæ–‡ä»¶...");
        
        // å¸¸è§çš„Blenderå®‰è£…è·¯å¾„
        let common_paths = vec![
            "C:/Program Files/Blender Foundation",
            "D:/Program Files/Blender Foundation",
            "C:/Program Files (x86)/Blender Foundation",
        ];
        
        // é¦–å…ˆè®©ç”¨æˆ·é€‰æ‹©Blenderä¸»ç›®å½?        let selected_blender_dir = rfd::FileDialog::new()
            .set_title("é€‰æ‹©Blenderå®‰è£…ç›®å½•")
            .set_directory(common_paths[0])
            .pick_folder();
            
        if let Some(blender_dir) = selected_blender_dir {
            // åªæ˜¾ç¤ºç›®å½•åç§°ï¼Œé¿å…è¿‡é•¿
            let dir_name = blender_dir.file_name()
                .map_or_else(|| "[æœªçŸ¥ç›®å½•]".to_string(),
                          |name| name.to_string_lossy().to_string());
            self.state.add_log(&format!("é€‰æ‹©äº†Blenderç›®å½•: {}", dir_name));
            
            // åœ¨é€‰å®šç›®å½•ä¸­æŸ¥æ‰¾ç‰ˆæœ¬ç›®å½•ï¼ˆå¦‚Blender 4.3ï¼?            let mut version_dirs = Vec::new();
            if let Ok(entries) = std::fs::read_dir(&blender_dir) {
                for entry in entries.filter_map(|e| e.ok()) {
                    let path = entry.path();
                    if path.is_dir() {
                        let dir_name = path.file_name().unwrap_or_default().to_string_lossy();
                        if dir_name.starts_with("Blender ") {
                            version_dirs.push(path.clone());
                            self.state.add_log(&format!("æ‰¾åˆ°Blenderç‰ˆæœ¬: {}", dir_name));
                        }
                    }
                }
            }
            
            // å¦‚æœæ‰¾åˆ°ç‰ˆæœ¬ç›®å½•ï¼Œè®©ç”¨æˆ·é€‰æ‹©
            let selected_version_dir = if !version_dirs.is_empty() {
                // å¦‚æœåªæœ‰ä¸€ä¸ªç‰ˆæœ¬ç›®å½•ï¼Œç›´æ¥ä½¿ç”¨
                if version_dirs.len() == 1 {
                    Some(version_dirs[0].clone())
                } else {
                    // åˆ›å»ºç‰ˆæœ¬ç›®å½•åç§°åˆ—è¡¨ï¼Œä¾›ç”¨æˆ·é€‰æ‹©
                    let version_dir_names: Vec<String> = version_dirs.iter()
                        .map(|p| p.file_name().unwrap_or_default().to_string_lossy().to_string())
                        .collect();
                        
                    // è®©ç”¨æˆ·ä»å¯¹è¯æ¡†ä¸­é€‰æ‹©ç‰ˆæœ¬
                    let selected_result = rfd::MessageDialog::new()
                        .set_title("é€‰æ‹©Blenderç‰ˆæœ¬")
                        .set_description(&format!("æ‰¾åˆ°å¤šä¸ªBlenderç‰ˆæœ¬ï¼Œè¯·é€‰æ‹©ä¸€ä¸?\n{}", 
                            version_dir_names.join("\n")))
                        .set_buttons(rfd::MessageButtons::OkCancel)
                        .show();
                        
                    if selected_result {
                        // å¦‚æœç”¨æˆ·ç‚¹å‡»ç¡®å®šï¼Œè®©ä»–ä»¬é€‰æ‹©å…·ä½“çš„ç‰ˆæœ¬ç›®å½?                        rfd::FileDialog::new()
                            .set_title("é€‰æ‹©Blenderç‰ˆæœ¬ç›®å½•")
                            .set_directory(&blender_dir)
                            .pick_folder()
                    } else {
                        None
                    }
                }
            } else {
                // æ²¡æœ‰æ‰¾åˆ°æ ‡å‡†çš„ç‰ˆæœ¬ç›®å½•ï¼Œç›´æ¥ä½¿ç”¨æ‰€é€‰ç›®å½?                Some(blender_dir)
            };
            
            // å¦‚æœé€‰æ‹©äº†ç‰ˆæœ¬ç›®å½•ï¼Œç»§ç»­æŸ¥æ‰¾å­ç‰ˆæœ¬ç›®å½•ï¼ˆå¦?.3ï¼?            if let Some(version_dir) = selected_version_dir {
                self.state.add_log(&format!("é€‰æ‹©çš„ç‰ˆæœ¬ç›®å½? {}", version_dir.display()));
                
                // åœ¨ç‰ˆæœ¬ç›®å½•ä¸­æŸ¥æ‰¾å­ç‰ˆæœ¬ç›®å½•ï¼ˆå¦?.3ï¼?                let mut subversion_dirs = Vec::new();
                if let Ok(entries) = std::fs::read_dir(&version_dir) {
                    for entry in entries.filter_map(|e| e.ok()) {
                        let path = entry.path();
                        if path.is_dir() {
                            let dir_name = path.file_name().unwrap_or_default().to_string_lossy();
                            // æ£€æŸ¥æ˜¯å¦ä¸ºç‰ˆæœ¬å·æ ¼å¼ï¼ˆå¦?.3ï¼?                            if dir_name.chars().any(|c| c.is_digit(10)) && dir_name.contains('.') {
                                subversion_dirs.push(path.clone());
                                self.state.add_log(&format!("æ‰¾åˆ°å­ç‰ˆæœ¬ç›®å½? {}", dir_name));
                            }
                        }
                    }
                }
                
                // é€‰æ‹©è¦ä½¿ç”¨çš„å­ç‰ˆæœ¬ç›®å½?                let target_dir = if !subversion_dirs.is_empty() {
                    // å¦‚æœåªæœ‰ä¸€ä¸ªå­ç‰ˆæœ¬ç›®å½•ï¼Œè¯¢é—®ç”¨æˆ·æ˜¯å¦ä½¿ç”?                    if subversion_dirs.len() == 1 {
                        let result = rfd::MessageDialog::new()
                            .set_title("ç¡®è®¤å­ç‰ˆæœ¬ç›®å½?)
                            .set_description(&format!("æ˜¯å¦ä½¿ç”¨å­ç‰ˆæœ¬ç›®å½? {}?", 
                                subversion_dirs[0].file_name().unwrap_or_default().to_string_lossy()))
                            .set_buttons(rfd::MessageButtons::YesNo)
                            .show();
                            
                        if result {
                            subversion_dirs[0].clone()
                        } else {
                            version_dir
                        }
                    } else {
                        // è®©ç”¨æˆ·ä»å¤šä¸ªå­ç‰ˆæœ¬ç›®å½•ä¸­é€‰æ‹©
                        let selected_subversion = rfd::FileDialog::new()
                            .set_title("é€‰æ‹©Blenderå­ç‰ˆæœ¬ç›®å½?)
                            .set_directory(&version_dir)
                            .pick_folder();
                            
                        selected_subversion.unwrap_or(version_dir)
                    }
                } else {
                    version_dir
                };
                
                self.state.add_log(&format!("å°†åœ¨ç›®å½•ä¸­æœç´¢MOæ–‡ä»¶: {}", target_dir.display()));
                
                // åœ¨ç›®æ ‡ç›®å½•ä¸­æŸ¥æ‰¾MOæ–‡ä»¶
                let mut found_mo_files = Vec::new();
                
                // æ„å»ºå¯èƒ½çš„è¯­è¨€æ–‡ä»¶è·¯å¾„
                let mo_paths = vec![
                    target_dir.join("datafiles/locale/zh_HANS/LC_MESSAGES/blender.mo"),
                    target_dir.join("datafiles/locale/zh_CN/LC_MESSAGES/blender.mo"),
                    target_dir.join("locale/zh_HANS/LC_MESSAGES/blender.mo"),
                    target_dir.join("locale/zh_CN/LC_MESSAGES/blender.mo"),
                ];
                
                // æ£€æŸ¥æ¯ä¸ªè·¯å¾?                for path in mo_paths {
                    if path.exists() && path.is_file() {
                        self.state.add_log(&format!("æ‰¾åˆ°MOæ–‡ä»¶: {}", path.display()));
                        found_mo_files.push(path);
                    }
                }
                
                // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œå°è¯•é€’å½’æœç´¢
                if found_mo_files.is_empty() {
                    self.state.add_log(&format!("åœ¨æ ‡å‡†è·¯å¾„æœªæ‰¾åˆ°MOæ–‡ä»¶ï¼Œå°è¯•é€’å½’æœç´¢: {}", target_dir.display()));
                    self.search_mo_files_recursively(&target_dir, &mut found_mo_files);
                }
                
                // å¦‚æœæ‰¾åˆ°æ–‡ä»¶ï¼Œè®©ç”¨æˆ·é€‰æ‹©æˆ–è‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸?                if !found_mo_files.is_empty() {
                    // æŒ‰æ–‡ä»¶è·¯å¾„æ’åº?                    found_mo_files.sort();
                    
                    // å¦‚æœåªæœ‰ä¸€ä¸ªæ–‡ä»¶ï¼Œç›´æ¥ä½¿ç”¨å®?                    if found_mo_files.len() == 1 {
                        let file_path = found_mo_files[0].clone();
                        let orig_path = file_path.clone(); // å…‹éš†ä¸€ä»½ç”¨äºæ—¥å¿—æ˜¾ç¤?                        // å¤åˆ¶åˆ°BLMMç›®å½•å¹¶ä½¿ç”¨BLMMç›®å½•ä¸­çš„æ–‡ä»¶
                        if let Some(blmm_path) = self.clone_main_mo_to_blmm(&file_path) {
                            self.state.main_mo_file = Some(blmm_path.clone());
                            self.config.main_mo_file = Some(blmm_path);
                        } else {
                            self.state.main_mo_file = Some(file_path.clone());
                            self.config.main_mo_file = Some(file_path);
                        }
                        self.config.save().ok();
                        self.add_log_with_path("å·²è‡ªåŠ¨è®¾ç½®å”¯ä¸€æ‰¾åˆ°çš„MOæ–‡ä»¶", &orig_path);
                    } else {
                        // è®©ç”¨æˆ·ä»æ‰¾åˆ°çš„æ–‡ä»¶ä¸­é€‰æ‹©
                        self.state.add_log(&format!("æ‰¾åˆ° {} ä¸ªMOæ–‡ä»¶ï¼Œè¯·é€‰æ‹©ä¸€ä¸?", found_mo_files.len()));
                        
                        if let Some(selected_path) = rfd::FileDialog::new()
                            .set_title("é€‰æ‹©Blenderä¸­æ–‡MOæ–‡ä»¶")
                            .add_filter("MOæ–‡ä»¶", &["mo"])
                            .set_directory(found_mo_files[0].parent().unwrap_or(&PathBuf::from("/")))
                            .pick_file() {
                            
                            let orig_path = selected_path.clone(); // å…‹éš†ä¸€ä»½ç”¨äºæ—¥å¿—æ˜¾ç¤?                            // å¤åˆ¶åˆ°BLMMç›®å½•å¹¶ä½¿ç”¨BLMMç›®å½•ä¸­çš„æ–‡ä»¶
                            if let Some(blmm_path) = self.clone_main_mo_to_blmm(&selected_path) {
                                self.state.main_mo_file = Some(blmm_path.clone());
                                self.config.main_mo_file = Some(blmm_path);
                            } else {
                                self.state.main_mo_file = Some(selected_path.clone());
                                self.config.main_mo_file = Some(selected_path);
                            }
                            self.config.save().ok();
                            self.add_log_with_path("å·²è®¾ç½®ä¸»MOæ–‡ä»¶", &orig_path);
                        }
                    }
                } else {
                    self.state.add_log("æœªæ‰¾åˆ°Blenderä¸­æ–‡MOæ–‡ä»¶ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©ã€?);
                    
                    // æ‰“å¼€æ–‡ä»¶é€‰æ‹©å¯¹è¯æ¡?                    if let Some(file) = rfd::FileDialog::new()
                        .add_filter("MOæ–‡ä»¶", &["mo"])
                        .set_title("é€‰æ‹©Blenderä¸­æ–‡MOæ–‡ä»¶")
                        .set_directory(&target_dir)
                        .pick_file() {
                            // å¤åˆ¶åˆ°BLMMç›®å½•å¹¶ä½¿ç”¨BLMMç›®å½•ä¸­çš„æ–‡ä»¶
                            let orig_file = file.clone(); // å…‹éš†ä¸€ä»½ç”¨äºæ—¥å¿—æ˜¾ç¤?                            if let Some(blmm_path) = self.clone_main_mo_to_blmm(&file) {
                                self.state.main_mo_file = Some(blmm_path.clone());
                                self.config.main_mo_file = Some(blmm_path);
                            } else {
                                self.state.main_mo_file = Some(file.clone());
                                self.config.main_mo_file = Some(file);
                            }
                            self.config.save().ok();
                            self.add_log_with_path("å·²è®¾ç½®ä¸»MOæ–‡ä»¶", &orig_file);
                    }
                }
            }
        } else {
            self.state.add_log("æœªé€‰æ‹©Blenderç›®å½•ï¼Œæ“ä½œå–æ¶ˆã€?);
        }
    }
    
    // é€’å½’æœç´¢MOæ–‡ä»¶
    fn search_mo_files_recursively(&mut self, dir: &PathBuf, found_files: &mut Vec<PathBuf>) {
        // è®¾ç½®æœ€å¤§æ·±åº¦ä¸º8ï¼Œé¿å…æœç´¢å¤ªæ·±å¯¼è‡´æ€§èƒ½é—®é¢˜
        let max_depth = 8;
        
        for entry in walkdir::WalkDir::new(dir)
            .follow_links(true)
            .max_depth(max_depth)
            .into_iter()
            .filter_map(|e| e.ok()) {
            
            let path = entry.path();
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºMOæ–‡ä»¶
            if path.is_file() && path.extension().map_or(false, |e| e.to_string_lossy().to_lowercase() == "mo") {
                // æ£€æŸ¥æ–‡ä»¶è·¯å¾„æ˜¯å¦åŒ…å«ä¸­æ–‡ç›¸å…³å…³é”®è¯
                let path_str = path.to_string_lossy().to_lowercase();
                if (path_str.contains("zh_") || path_str.contains("chinese") || 
                    path_str.contains("zh-") || path_str.contains("/zh/") || 
                    path_str.contains("\\zh\\")) && path_str.contains("blender") {
                    
                    // è·å–æ–‡ä»¶åç”¨äºæ—¥å¿—æ˜¾ç¤?                    let file_name = path.file_name()
                        .map_or_else(|| "[æœªçŸ¥æ–‡ä»¶]".to_string(), 
                                   |name| name.to_string_lossy().to_string());
                    self.state.add_log(&format!("é€’å½’æœç´¢æ‰¾åˆ°MOæ–‡ä»¶: {}", file_name));
                    found_files.push(path.to_path_buf());
                }
            }
        }
    }

    fn add_log_with_path(&mut self, message: &str, path: &PathBuf) {
        // æå–æ–‡ä»¶åç”¨äºæ—¥å¿—æ˜¾ç¤?        let file_name = path.file_name()
            .map_or_else(|| "[æœªçŸ¥æ–‡ä»¶]".to_string(), 
                      |name| name.to_string_lossy().to_string());
        self.state.add_log(&format!("{}: {}", message, file_name));
    }

    // å¯¼å‡ºåŸºç¡€æ–‡ä»¶ï¼ˆä¸åˆå¹¶ï¼?    fn export_base_mo_file(&mut self) {
        // æ£€æŸ¥æ˜¯å¦æœ‰ä¸»MOæ–‡ä»¶
        if self.state.main_mo_file.is_none() {
            self.state.add_log("é”™è¯¯: è¯·å…ˆåœ¨è®¾ç½®ä¸­è®¾ç½®ä¸»MOæ–‡ä»¶");
            return;
        }
        
        let base_mo_file = self.state.main_mo_file.clone().unwrap();
        
        // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ?        if !base_mo_file.exists() {
            self.state.add_log(&format!("é”™è¯¯: åŸºç¡€MOæ–‡ä»¶ä¸å­˜åœ? {}", base_mo_file.display()));
            return;
        }
        
        // åˆ›å»ºè¾“å‡ºMOæ–‡ä»¶è·¯å¾„ - ä½¿ç”¨ç”¨æˆ·è®¾ç½®çš„è¾“å‡ºç›®å½•æˆ–æ¡Œé¢ä¸Šçš„"BLMMå¯¼å‡º"æ–‡ä»¶å¤?        let output_mo_path = if let Some(output_dir) = &self.state.output_directory {
            // ä½¿ç”¨ç”¨æˆ·è®¾ç½®çš„è¾“å‡ºç›®å½?            if let Err(e) = std::fs::create_dir_all(output_dir) {
                self.state.add_log(&format!("åˆ›å»ºè¾“å‡ºç›®å½•å¤±è´¥: {}", e));
                // å¦‚æœåˆ›å»ºç›®å½•å¤±è´¥ï¼Œå›é€€åˆ°æ¡Œé¢ä¸Šçš?BLMMå¯¼å‡º"æ–‡ä»¶å¤?                self.create_default_output_directory()
                    .map(|dir| dir.join("blender.mo"))
                    .unwrap_or_else(|| base_mo_file.with_file_name("blender.mo"))
            } else {
                // ä½¿ç”¨è®¾ç½®çš„è¾“å‡ºç›®å½?                output_dir.join("blender.mo")
            }
        } else {
            // æœªè®¾ç½®è¾“å‡ºç›®å½•ï¼Œä½¿ç”¨æ¡Œé¢ä¸Šçš„"BLMMå¯¼å‡º"æ–‡ä»¶å¤?            self.create_default_output_directory()
                .map(|dir| dir.join("blender.mo"))
                .unwrap_or_else(|| {
                    // å¦‚æœåˆ›å»ºæ¡Œé¢æ–‡ä»¶å¤¹å¤±è´¥ï¼Œå›é€€åˆ°ä¸»MOæ–‡ä»¶æ‰€åœ¨ç›®å½?                    if let Some(parent) = base_mo_file.parent() {
                        parent.join("blender.mo")
                    } else {
                        base_mo_file.with_file_name("blender.mo")
                    }
                })
        };
        
        // å¤åˆ¶æ–‡ä»¶
        self.state.add_log(&format!("æ­£åœ¨å¯¼å‡ºåŸºç¡€MOæ–‡ä»¶åˆ? {}", output_mo_path.display()));
        match std::fs::copy(&base_mo_file, &output_mo_path) {
            Ok(_) => {
                self.state.add_log(&format!("åŸºç¡€MOæ–‡ä»¶å¯¼å‡ºæˆåŠŸ: {}", output_mo_path.display()));
                
                // å°è¯•æ‰“å¼€è¾“å‡ºç›®å½•
                if let Some(parent) = output_mo_path.parent() {
                    if let Err(e) = open::that(parent) {
                        self.state.add_log(&format!("å°è¯•æ‰“å¼€è¾“å‡ºç›®å½•å¤±è´¥: {}", e));
                    }
                }
            },
            Err(e) => {
                self.state.add_log(&format!("å¯¼å‡ºåŸºç¡€MOæ–‡ä»¶å¤±è´¥: {}", e));
            }
        }
    }

    // æ·»åŠ åˆå¹¶POæ–‡ä»¶æ–¹æ³•
    fn merge_po_files(&mut self) {
        // æ£€æŸ¥æ˜¯å¦æœ‰ä¸»MOæ–‡ä»¶
        if self.state.main_mo_file.is_none() {
            self.state.add_log("é”™è¯¯: è¯·å…ˆåœ¨è®¾ç½®ä¸­è®¾ç½®ä¸»MOæ–‡ä»¶");
            return;
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰å¯ç”¨çš„è¯­è¨€åŒ?        let enabled_mods = self.state.installed_mods.iter()
            .filter(|m| m.status == ModStatus::Enabled)
            .count();
            
        if enabled_mods == 0 && !self.state.needs_remerge {
            self.state.add_log("é”™è¯¯: æ²¡æœ‰å¯ç”¨çš„è¯­è¨€åŒ…éœ€è¦åˆå¹?);
            return;
        }
        
        // è®¾ç½®åˆå¹¶çŠ¶æ€?        self.state.is_merging = true;
        self.state.merge_progress = 0.0;
        self.state.merge_progress_anim = 0;
        
        // åœ¨çº¿ç¨‹ä¸­æ‰§è¡Œåˆå¹¶ï¼Œä»¥é¿å…UIå†»ç»“
        let tx = self.merge_tx.clone();
        let po_files: Vec<PathBuf> = self.state.installed_mods.iter()
            .filter(|m| m.status == ModStatus::Enabled)
            .map(|m| m.path.clone())
            .collect();
        let ignore_main = self.state.ignore_main_mo_entries;
        let main_mo_file = self.state.main_mo_file.clone().unwrap();
        
        self.thread_pool.spawn(move || {
            // é€šçŸ¥å¼€å§?            let _ = tx.send(MergeStatus::Started);
            
            // åˆ›å»ºç¼“å­˜ç›®å½•
            let cache_dir = if let Some(local_dir) = dirs::data_local_dir() {
                local_dir.join("BLMM").join("cache")
            } else {
                std::env::temp_dir().join("BLMM").join("cache")
            };
            
            if let Err(e) = std::fs::create_dir_all(&cache_dir) {
                let _ = tx.send(MergeStatus::Failed(format!("åˆ›å»ºç¼“å­˜ç›®å½•å¤±è´¥: {}", e)));
                return;
            }
            
            // ç¼“å­˜åˆå¹¶POçš„è·¯å¾?            let cached_po_path = cache_dir.join("cached_merged.po");
            
            // æ›´æ–°è¿›åº¦ 25%
            let _ = tx.send(MergeStatus::Progress(0.25));
            
            // åˆå¹¶POæ–‡ä»¶
            match po_merger::merge_po_files(&po_files, &cached_po_path, ignore_main) {
                Ok(_) => {
                    // æ›´æ–°è¿›åº¦ 75%
                    let _ = tx.send(MergeStatus::Progress(0.75));
                    
                    // å®Œæˆ
                    let _ = tx.send(MergeStatus::Completed(cached_po_path));
                },
                Err(e) => {
                    let _ = tx.send(MergeStatus::Failed(format!("åˆå¹¶POæ–‡ä»¶å¤±è´¥: {}", e)));
                }
            }
        });
    }
}

impl eframe::App for App {
    fn update(&mut self, ctx: &egui::Context, frame: &mut eframe::Frame) {
        // Process background task results
        self.process_conversion_results();
        
        // Process merge status updates
        self.process_merge_status();
        
        // è®¾ç½®ä¸»é¢˜
        let visuals = crate::models::ThemeManager::get_visuals(&self.config.theme);
        ctx.set_visuals(visuals);
        
        // ä¸ºäº†å‘åå…¼å®¹ï¼Œä¿æŒdark_modeæ ‡å¿—ä¸ä¸»é¢˜åŒæ­?        self.state.dark_mode = self.config.theme != crate::models::AppTheme::Light 
            && self.config.theme != crate::models::AppTheme::Sepia;
        
        // é¡¶éƒ¨èœå•æ ?        egui::TopBottomPanel::top("top_panel").show(ctx, |ui| {
            egui::menu::bar(ui, |ui| {
                // ç§»é™¤å…¨å±€æš?äº®æ¨¡å¼æŒ‰é’?                // egui::widgets::global_dark_light_mode_buttons(ui);
                // ui.add_space(8.0);
                
                // æ–‡ä»¶èœå•
                ui.menu_button("æ–‡ä»¶", |ui| {
                    if ui.button("æ·»åŠ è¯­è¨€åŒ?).clicked() {
                        self.state.show_mods = true;
                        ui.close_menu();
                    }
                    
                    ui.separator();
                    
                    // è®¾ç½®é€‰é¡¹ - ç›´æ¥æ‰“å¼€è¯­è¨€åŒ…ç®¡ç†å™¨çš„è®¾ç½®æ ‡ç­¾é¡µ
                    if ui.button("è®¾ç½®").clicked() {
                        self.state.show_mods = true;
                        self.state.show_mods_tab = ModsTab::Settings;
                        ui.close_menu();
                    }
                    
                    ui.separator();
                    
                    if ui.button("é€€å‡?).clicked() {
                        frame.close();
                        // å…³é—­æ—¶ä¿å­˜é…ç½?                        self.save_config_on_exit();
                        ui.close_menu();
                    }
                });
                
                // å·¥å…·èœå•
                ui.menu_button("å·¥å…·", |ui| {
                    if ui.button("åˆå¹¶è¯­è¨€åŒ?).clicked() {
                        self.merge_po_files();
                        ui.close_menu();
                    }
                    
                    if ui.button("å¯¼å‡ºåŸºç¡€MOæ–‡ä»¶").clicked() {
                        self.export_base_mo_file();
                        ui.close_menu();
                    }
                    
                    ui.separator();
                    
                    if ui.button("æ‰¹é‡å¤„ç†").clicked() {
                        self.batch_process();
                        ui.close_menu();
                    }
                });
                
                // çª—å£èœå•
                ui.menu_button("çª—å£", |ui| {
                    if ui.button("è¯­è¨€åŒ…ç®¡ç†å™¨").clicked() {
                        self.state.show_mods = true;
                        ui.close_menu();
                    }
                });
                
                // å¸®åŠ©èœå•
                ui.menu_button("å¸®åŠ©", |ui| {
                    if ui.button("ä½¿ç”¨å¸®åŠ©").clicked() {
                        self.state.show_help = true;
                        ui.close_menu();
                    }
                    
                    ui.separator();
                    
                    if ui.button("å…³äº").clicked() {
                        self.state.show_about = true;
                        ui.close_menu();
                    }
                });
            });
        });
        
        egui::CentralPanel::default().show(ctx, |ui| {
            if self.state.show_mods {
                self.render_mods(ui);
            } else {
                self.render_header(ui);
                self.render_operations(ui);
                ui.separator();
                
                if ui.button("è¯­è¨€åŒ…ç®¡ç†å™¨").clicked() {
                    self.state.show_mods = true;
                }
                
                ui.separator();
                self.render_logs(ui);
            }
        });
        
        self.render_settings(ctx);
        self.show_help_window(ctx);
        self.render_rename_dialog(ctx);
    }
    
    // Override the on_exit method to ensure configuration is saved
    fn on_exit(&mut self, _gl: Option<&eframe::glow::Context>) {
        self.save_config_on_exit();
    }
}

#[allow(dead_code)]
fn format_system_time(time: SystemTime) -> String {
    match time.duration_since(UNIX_EPOCH) {
        Ok(duration) => {
            let datetime = Local.timestamp_opt(duration.as_secs() as i64, 0).unwrap();
            datetime.format("%Y-%m-%d %H:%M:%S").to_string()
        },
        Err(_) => "Invalid time".to_string()
    }
} 
